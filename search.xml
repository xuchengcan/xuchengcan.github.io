<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java序列化问题]]></title>
    <url>%2F2019%2FJava%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[序列化 ID 的问题 静态变量序列化 父类的序列化与 Transient 关键字 对敏感字段加密 序列化存储规则 序列化 ID 的问题虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L） 序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。 典型例子 Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。 静态变量序列化序列化时，并不保存静态变量，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。 父类的序列化与 Transient 关键字要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。 Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 典型例子 我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。 对敏感字段加密在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作。 序列化存储规则对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如下 31 36 true Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。 参考资料：https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java序列化,Transient关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备分辨率与Bitmap]]></title>
    <url>%2F2019%2FAndroid%2F%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8EBitmap%2F</url>
    <content type="text"><![CDATA[设备分辨率 density 0.75 1 1.5 2 3 3.5 4 densityDpi 120 160 240 320 480 560 640 DpiFolder ldpi mdpi hdpi xhdpi xxhdpi xxxhdpi xxxxhdpi Dpi范围 密度 0dpi ~ 120dpi ldpi 120dpi ~ 160dpi mdpi 160dpi ~ 240dpi hdpi 240dpi ~ 320dpi xhdpi 320dpi ~ 480dpi xxhdpi 480dpi ~ 640dpi xxxhdp 内存占用 Bitmap内存占用 ≈ 像素数据总大小 = 图片宽 × 图片高× (设备分辨率/资源目录分辨率)^2 × 每个像素的字节大小 单个像素的字节大小 Config 占用字节大小（byte） 说明 ALPHA_8 (1) 1 单透明通道 RGB_565 (3) 2 简易RGB色调 ARGB_4444 (4) 4 已废弃 ARGB_8888 (5) 4 24位真彩色 RGBA_F16 (6) 8 Android 8.0 新增（更丰富的色彩表现HDR） HARDWARE (7) Special Android 8.0 新增 （Bitmap直接存储在graphic memory）注1 不同Android版本时的Bitmap内存模型 API级别 API 10 - API 11 ~ API 25 API 26 + Bitmap对象存放 Java heap Java heap Java heap 像素(pixel data)数据存放| native heap| Java heap |native heap 如果没有在AndroidManifest中启用largeheap，那么Java 堆内存达到192M的时候就会崩溃，对于现在动辄4G的手机而言，存在严重的资源浪费，ios的一个APP几乎能用近所有的可用内存（除去系统开支），8.0之后，Android也向这个方向靠拢，最好的下手对象就是Bitmap，因为它是耗内存大户。图片内存被转移到native之后，一个APP的图片处理不仅能使用系统绝大多数内存，还能降低Java层内存使用，减少OOM风险。不过，内存无限增长的情况下，也会导致APP崩溃，但是这种崩溃已经不是OOM崩溃了，Java虚拟机也不会捕获，按道理说，应该属于linux的OOM了。 8.0之后的Bitmap内存回收机制NativeAllocationRegistry是Android 8.0引入的一种辅助自动回收native内存的一种机制，当Java对象因为GC被回收后，NativeAllocationRegistry可以辅助回收Java对象所申请的native内存 参考资料：https://www.jianshu.com/p/3f6f6e4f1c88https://www.jianshu.com/p/d5714e8987f3https://blog.csdn.net/guolin_blog/article/details/50727753]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BroadcastReceiver]]></title>
    <url>%2F2019%2FAndroid%2FBroadcastReceiver%2F</url>
    <content type="text"><![CDATA[广播被分为两种不同的类型：“普通广播（Normal broadcasts）”和“有序广播（Ordered broadcasts）”。 普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播； 然而有序广播是按照接收者声明的优先级别（声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000。也可以调用IntentFilter对象的setPriority()进行设置），被接收者依次接收广播。 静态注册和动态注册区别8.0 后，Android 推荐使用动态广播注册，大部分静态广播都已失效。 动态注册广播不是常驻型广播，也就是说广播跟随activity的生命周期。注意: 在activity结束前，移除广播接收器。 静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 当广播为有序广播时： 优先级高的先接收 同优先级的广播接收器，动态优先于静态 同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。 当广播为普通广播时： 无视优先级，动态广播接收器优先于静态广播接收器 同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。 小结：在Android 中如果要发送一个广播必须使用sendBroadCast 向系统发送对其感兴趣的广播接收器中。使用广播必须要有一个intent 对象必设置其action动作对象使用广播必须在配置文件中显式的指明该广播对象每次接收广播都会重新生成一个接收广播的对象在BroadCastReceiver中尽量不要处理太多逻辑问题，建议复杂的逻辑交给Activity 或者 Service 去处理如果在AndroidManifest.xml中注册，当应用程序关闭的时候，也会接收到广播。在应用程序中注册就不产生这种情况了。 参考资料：https://www.jianshu.com/p/51aaa65d5d25]]></content>
      <categories>
        <category>Android</category>
        <category>四大组件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 开发常用命令]]></title>
    <url>%2F2018%2FAndroid%2FAndroid%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Android 开发常用命令整理参考 《Android 应用安全防护和逆向分析》 adb shell 命令 adb shell getprop 查看系统属性 12vivo： getprop ro.build.version.opporom 获取系统版本号miui： getprop ro.miui.ui.version.name adb shell dumpsys activity top 查看当前应用的 activity 信息 adb shell dumpsys package [package] 查看指定包名应用的详细信息（相当于应用的 AndroidManifest.xml） adb shell dumpsys meminfo [pname/id] 查看指定进程名或者进程 id 的内存信息 adb shell dumpsys dbinfo [package] 可以查看指定包名应用的数据库存储信息（包括存储的 SQL 语句） adb shell screencap -p [路径] 截屏到指定路径 123adb shell screencap -p /sdcard/temp.pngadb pull /sdcard/temp.png D:\start D:\temp.png adb forward [(远程端) 协议：端口号] [(设备端) 协议：端口号] 设备的端口转发，该命令在 IDA 调试中非常有用 adb forward tcp:8700 jdwp:1786 adb jdwp 查看设备中可以被调试的应用的进程号 adb shell 中的命令 run-as [package name] 在非 root 设备中查看指定 debug 模式的包名应用沙盒数据 psps | grep 过滤内容ps -t [pid] 查看 pid 对应的进程信息 pm clear [package name] 清楚指定包名应用的数据 am start 启动一个应用 1am start -n [package]/[package].[activity] 注意：可以用 debug 方式启动应用 ( am start -D -n … ）。特别在反编译调试应用的时候，可能需要 debug 方式启动应用。 am startservice 启动一个服务 1am startservice -n [package]/[package].[service] am broadcast 发送一个广播 1am broadcast -a [broadcast] netcfg 查看设备 ip 地址 netstat 查看设备的端口号信息 app_process 运行 java 代码 这个命令主要用于 Android 中一些特殊的开发场景中，想启动一个 jar 包，不过这个 jar 包有要求：需要 dx 命令把 dex 文件转化成 jar 包功能，实际上它不是一个正常的 jar 包了，而是一个包含了 class.dex 文件的压缩文件了。 dalvikvm 运行一个 dex 文件 有时候为了测试一个 dex 文件功能可以用到这个命令，与上面的命令有很大的相似之处，只是运行的文件不一样。 top 查看当前应用的 CPU 信息 12345678tap [-n/-m/-d/-s/-t]-m 最多显示多少个进程-n 刷新次数-d 刷新间隔时间-s 按哪列排序-t 显示线程信息而不是进程top -d 1 -m 10 这个命令在分析应用性能的时候非常有用，可以用 grep 过滤想要分析的应用信息，查看它的当前 CPU 使用率。 getprop 查看系统属性值 getprop ro.debuggable root 设备之后，可以通过修改这些系统属性。比如 debug 开关，让所有应用都处于可调试状态。 操作 apk 命令 aapt 查看 apk 中的信息以及编辑 apk 程序包 1aapt dump xmltree [.apk] [.xml] dexdump [dex 文件路径] 查看一个 dex 文件的详细信息 进程命令 cat /proc/[pid]/maps 查看当前进程的内存映射信息，比如加载了哪些 so 文件， dex 文件等。 cat /proc/[pid]/status 查看当前进程的状态信息，比如 TracerPid 。 adb 获取手机 apk 列出手机包名：adb shell pm list package 获取 apk 安装路径：adb shell pm path ‘package name’adb shell pm path com.google.android.youtubepackage:/data/app/com.google.android.youtube-1/base.apk 使用 pull 命令获取apk：adb pull ‘package-path’ ‘new.apk’adb pull /data/app/com.google.android.youtube-1/base.apk youtube.apk/data/app/com.google.android.youtube-1/base.apk: 1 file pulled. 2.7 MB/s (21504340 bytes in 7.724s) 总结： adb shell pm 命令获取安装包路径， adb pull 命令拿到安装包。 adb wifi 调试 adb tcpip [端口号（随便写个大点的比如：5555）] adb connect [手机 ip] adb usb （换回usb模式 ）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 应用安全防护和逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin笔记-函数与 Lambda 表达式]]></title>
    <url>%2F2018%2FKotlin%2FKotlin%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数与 Lambda 表达式笔记 函数函数声明Kotlin 中的函数使用 fun 关键字声明： 默认参数123fun read(b: Array&lt;Byte&gt;, off: Int = 0, len: Int = b.size) &#123;……&#125; 覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值： 1234567open class A &#123; open fun foo(i: Int = 10) &#123; …… &#125;&#125;class B : A() &#123; override fun foo(i: Int) &#123; …… &#125; // 不能有默认值&#125; 可变数量的参数（Varargs）函数的参数（通常是最后一个）可以用 vararg 修饰符标记： 123456fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123; val result = ArrayList&lt;T&gt;() for (t in ts) // ts is an Array result.add(t) return result&#125; 允许将可变数量的参数传递给函数： 1val list = asList(1, 2, 3) 当我们调用 vararg 函数时，我们可以一个接一个地传参，例如 asList(1, 2, 3)，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 *）： 12val a = arrayOf(1, 2, 3)val list = asList(-1, 0, *a, 4) 中缀表示法标有 infix 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求： 它们必须是成员函数或扩展函数； 它们必须只有一个参数； 其参数不得接受可变数量的参数且不能有默认值。 123456789infix fun Int.shl(x: Int): Int &#123; // ……&#125;// 用中缀表示法调用该函数1 shl 2// 等同于这样1.shl(2) 函数作用域在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。 局部函数Kotlin 支持局部函数，即一个函数在另一个函数内部： 局部函数可以访问外部函数（即闭包）的局部变量 尾递归函数Kotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 tailrec 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本： 12tailrec fun findFixPoint(x: Double = 1.0): Double = if (x == Math.cos(x)) x else findFixPoint(Math.cos(x)) 这段代码计算余弦的不动点（fixpoint of cosine），这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，产生0.7390851332151607的结果。最终代码相当于这种更传统风格的代码： 12345678private fun findFixPoint(): Double &#123; var x = 1.0 while (true) &#123; val y = Math.cos(x) if (x == y) return x x = y &#125;&#125; 要符合 tailrec 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前尾部递归只在 JVM 后端中支持。 高阶函数与 lambda 表达式Kotlin 函数都是头等的，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以像操作任何其他非函数值一样操作函数。 为促成这点，作为一门静态类型编程语言的 Kotlin 使用一系列函数类型来表示函数并提供一组特定的语言结构，例如 lambda 表达式。 高阶函数高阶函数是将函数用作参数或返回值的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344fun &lt;T, R&gt; Collection&lt;T&gt;.fold( initial: R, combine: (acc: R, nextElement: T) -&gt; R): R &#123; var accumulator: R = initial for (element: T in this) &#123; accumulator = combine(accumulator, element) &#125; return accumulator&#125;fun main(args: Array&lt;String&gt;) &#123; //sampleStart val items = listOf(1, 2, 3, 4, 5) // Lambdas 表达式是花括号括起来的代码块。 items.fold(0, &#123; // 如果一个 lambda 表达式有参数，前面是参数，后跟“-&gt;” acc: Int, i: Int -&gt; print("acc = $acc, i = $i, ") val result = acc + i println("result = $result") // lambda 表达式中的最后一个表达式是返回值： result &#125;) // lambda 表达式的参数类型是可选的，如果能够推断出来的话： val joinedToString = items.fold("Elements:", &#123; acc, i -&gt; acc + " " + i &#125;) // 函数引用也可以用于高阶函数调用： val product = items.fold(1, Int::times) //sampleEnd println("joinedToString = $joinedToString") println("product = $product")&#125;输出：acc = 0, i = 1, result = 1acc = 1, i = 2, result = 3acc = 3, i = 3, result = 6acc = 6, i = 4, result = 10acc = 10, i = 5, result = 15joinedToString = Elements: 1 2 3 4 5product = 120 函数类型Kotlin 使用类似 (Int) -&gt; String 的一系列函数类型来处理函数的声明： val onClick: () -&gt; Unit = ……。 这些类型具有与函数签名相对应的特殊表示法，即它们的参数和返回值： 如需将函数类型指定为可空，请使用圆括号：((Int, Int) -&gt; Int)?。箭头表示法是右结合的，(Int) -&gt; (Int) -&gt; Unit 与前述示例等价，但不等于 ((Int) -&gt; (Int)) -&gt; Unit。 函数式编程12345678910111213141516171819fun main(args: Array&lt;String&gt;) &#123; val oddLength = compose(::isOdd, ::length) val strings = listOf("a", "ab", "abc") println(strings.filter(oddLength))&#125;fun isOdd(x: Int) = x % 2 != 0 //求基数fun length(s: String) = s.lengthfun &lt;A, B, C&gt; compose ( f: (B) -&gt; C , g: (A) -&gt; B ) : (A) -&gt; C &#123; return &#123; x -&gt; f(g(x)) &#125;&#125;fun &lt;String, Int, Boolean&gt; compose2 ( f: (Int) -&gt; Boolean , g: (String) -&gt; Int ) : (String) -&gt; Boolean &#123; return &#123; x -&gt; f(g(x)) &#125;&#125;输出：[a,abc] Lambda 表达式语法Lambda 表达式的完整语法形式如下： 1val sum = &#123; x: Int, y: Int -&gt; x + y &#125; 如果我们把所有可选标注都留下，看起来如下： 1val sum: (Int, Int) -&gt; Int = &#123; x, y -&gt; x + y &#125; 将 lambda 表达式传给最后一个参数在 Kotlin 中有一个约定：如果函数的最后一个参数接受函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外： 1val product = items.fold(1) &#123; acc, e -&gt; acc * e &#125; 如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略： 1run &#123; println("...") &#125; it：单个参数的隐式名称一个 lambda 表达式只有一个参数是很常见的。 如果编译器自己可以识别出签名，也可以不用声明唯一的参数并忽略 -&gt;。 该参数会隐式声明为 it： 1ints.filter &#123; it &gt; 0 &#125; // 这个字面值是“(it: Int) -&gt; Boolean”类型的 从 lambda 表达式中返回一个值我们可以使用限定的返回语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。 因此，以下两个片段是等价的： 123456789ints.filter &#123; val shouldFilter = it &gt; 0 shouldFilter&#125;ints.filter &#123; val shouldFilter = it &gt; 0 return@filter shouldFilter&#125; 下划线用于未使用的变量如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称： 1map.forEach &#123; _, value -&gt; println("$value!") &#125; 闭包Lambda 表达式或者匿名函数（以及局部函数和对象表达式） 可以访问其 闭包 ，即在外部作用域中声明的变量。 与 Java 不同的是可以修改闭包中捕获的变量： 12345var sum = 0ints.filter &#123; it &gt; 0 &#125;.forEach &#123; sum += it&#125;print(sum) 内联函数使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。 但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况： 内联函数 协程协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器！）上调度执行，而代码则保持如同顺序执行一样简单。 挂起函数当我们调用标记有特殊修饰符 suspend 的函数时，会发生挂起： 123suspend fun doSomething(foo: Foo): Bar &#123; ……&#125; 这样的函数称为挂起函数，因为调用它们可能挂起协程（如果相关调用的结果已经可用，库可以决定继续进行而不挂起）。挂起函数能够以与普通函数相同的方式获取参数和返回值，但它们只能从协程、其他挂起函数以及内联到其中的函数字面值中调用。 事实上，要启动协程，必须至少有一个挂起函数，它通常是匿名的（即它是一个挂起 lambda 表达式）。让我们来看一个例子，一个简化的 async() 函数（源自 kotlinx.coroutines 库）： 1fun &lt;T&gt; async(block: suspend () -&gt; T)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin笔记-类与对象（下）]]></title>
    <url>%2F2018%2FKotlin%2FKotlin%E7%AC%94%E8%AE%B0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Kotlin 类与对象笔记（下） 泛型型变Java 类型系统中最棘手的部分之一是通配符类型（参见 Java Generics FAQ）。 而 Kotlin 中没有。 相反，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。 声明处型变消费者 in, 生产者 out! 声明处型变 类型投影1234567fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) &#123; // ……&#125;fun fill(dest: Array&lt;in String&gt;, value: String) &#123; // ……&#125; 星投影 – 看不懂。。。泛型约束 上界最常见的约束类型是与 Java 的 extends 关键字对应的 上界： 123fun &lt;T : Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) &#123; // ……&#125; 冒号之后指定的类型是上界：只有 Comparable 的子类型可以替代 T。 例如： 12sort(listOf(1, 2, 3)) // OK。Int 是 Comparable&lt;Int&gt; 的子类型sort(listOf(HashMap&lt;Int, String&gt;())) // 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型 默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句： 12345fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt; where T : CharSequence, T : Comparable&lt;T&gt; &#123; return list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;&#125; 枚举类枚举类的最基本的用法是实现类型安全的枚举： 123enum class Direction &#123; NORTH, SOUTH, WEST, EAST&#125; 就像在 Java 中一样，Kotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）： 12EnumClass.valueOf(value: String): EnumClassEnumClass.values(): Array&lt;EnumClass&gt; 对象有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。 Java 用匿名内部类 处理这种情况。 Kotlin 用对象表达式和对象声明对这个概念稍微概括了下。 对象表达式要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写： 123456789window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; // …… &#125; override fun mouseEntered(e: MouseEvent) &#123; // …… &#125;&#125;) 如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定： 123456789open class A(x: Int) &#123; public open val y: Int = x&#125;interface B &#123;……&#125;val ab: A = object : A(1), B &#123; override val y = 15&#125; 任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写： 1234567fun foo() &#123; val adHoc = object &#123; var x: Int = 0 var y: Int = 0 &#125; print(adHoc.x + adHoc.y)&#125; 请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。 12345678910111213141516class C &#123; // 私有函数，所以其返回类型是匿名对象类型 private fun foo() = object &#123; val x: String = "x" &#125; // 公有函数，所以其返回类型是 Any fun publicFoo() = object &#123; val x: String = "x" &#125; fun bar() &#123; val x1 = foo().x // 没问题 val x2 = publicFoo().x // 错误：未能解析的引用“x” &#125;&#125; 就像 Java 匿名内部类一样，对象表达式中的代码可以访问来自包含它的作用域的变量。 （与 Java 不同的是，这不仅限于 final 变量。） 123456789101112131415fun countClicks(window: JComponent) &#123; var clickCount = 0 var enterCount = 0 window.addMouseListener(object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; clickCount++ &#125; override fun mouseEntered(e: MouseEvent) &#123; enterCount++ &#125; &#125;) // ……&#125; 对象声明单例模式在一些场景中很有用， 而 Kotlin（继 Scala 之后）使单例声明变得很容易： 12345678object DataProviderManager &#123; fun registerDataProvider(provider: DataProvider) &#123; // …… &#125; val allDataProviders: Collection&lt;DataProvider&gt; get() = // ……&#125; 这称为对象声明。并且它总是在 object 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。 对象声明的初始化过程是线程安全的。 如需引用该对象，我们直接使用其名称即可： 1DataProviderManager.registerDataProvider(……) 伴生对象类内部的对象声明可以用 companion 关键字标记： 12345class MyClass &#123; companion object Factory &#123; fun create(): MyClass = MyClass() &#125;&#125; 该伴生对象的成员可通过只使用类名作为限定符来调用： 1val instance = MyClass.create() 可以省略伴生对象的名称，在这种情况下将使用名称 Companion： 123456class MyClass &#123; companion object &#123; &#125;&#125;val x = MyClass.Companion 请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口： 12345678910interface Factory&lt;T&gt; &#123; fun create(): T&#125;class MyClass &#123; companion object : Factory&lt;MyClass&gt; &#123; override fun create(): MyClass = MyClass() &#125;&#125; 当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。 对象表达式和对象声明之间的语义差异对象表达式和对象声明之间有一个重要的语义差别： 对象表达式是在使用他们的地方立即执行（及初始化）的； 对象声明是在第一次被访问到时延迟初始化的； 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。 委托委托 委托属性委托属性]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin笔记-类与对象（上）]]></title>
    <url>%2F2018%2FKotlin%2FKotlin%E7%AC%94%E8%AE%B0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Kotlin 类与对象笔记（上） 类与继承类Kotlin 中使用关键字 class 声明类 1234class Invoice &#123;&#125;class Empty 构造函数在 Kotlin 中的一个类可以有一个主构造函数和一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。 123456class Person constructor(firstName: String) &#123;&#125;如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。constructor 可省略 主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的 初始化块（initializer blocks）中。 12345678class Person constructor(firstName: String) &#123; val firstProperty = "First property: $name".also(::println) init &#123; println("First initializer block that prints $&#123;name&#125;") &#125;&#125; 如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面： 1class Customer public @Inject constructor(name: String) &#123; …… &#125; 次构造函数类也可以声明前缀有 constructor 的次构造函数：12345class Person &#123; constructor(parent: Person) &#123; parent.children.add(this) &#125;&#125; 创建类的实例要创建一个类的实例，我们就像普通函数一样调用构造函数： 123val invoice = Invoice()val customer = Customer("Joe Smith") 注意 Kotlin 并没有 new 关键字。 继承在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类： 注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。 类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。默认情况下，在 Kotlin 中所有的类都是 final 123open class Base(p: Int) // Base 需为 open 才可以被 Derived 继承class Derived(p: Int) : Base(p) 覆盖方法1234567open class Base &#123; open fun v() &#123;&#125; fun nv() &#123;&#125;&#125;class Derived() : Base() &#123; override fun v() &#123;&#125;&#125; Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字： 123open class AnotherDerived() : Base() &#123; final override fun v() &#123;&#125;&#125; 覆盖属性你可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 你可以在主构造函数中使用 override 关键字作为属性声明的一部分。 派生类初始化顺序在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。 例子12345678910111213141516171819202122232425262728293031323334//sampleStartopen class Base(val name: String) &#123; init &#123; println("Initializing Base") &#125; open val size: Int = name.length.also &#123; println("Initializing size in Base: $it") &#125;&#125;class Derived( name: String, val lastName: String) : Base(name.capitalize().also &#123; println("Argument for Base: $it") &#125;) &#123; init &#123; println("Initializing Derived") &#125; override val size: Int = (super.size + lastName.length).also &#123; println("Initializing size in Derived: $it") &#125;&#125;//sampleEndfun main(args: Array&lt;String&gt;) &#123; println("Constructing Derived(\"hello\", \"world\")") val d = Derived("hello", "world")&#125;输出Constructing Derived("hello", "world")Argument for Base: HelloInitializing BaseInitializing size in Base: 5Initializing DerivedInitializing size in Derived: 10 这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。 调用超类实现派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现： 在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer： 覆盖规则在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super： 1234567891011121314151617open class A &#123; open fun f() &#123; print("A") &#125; fun a() &#123; print("a") &#125;&#125;interface B &#123; fun f() &#123; print("B") &#125; // 接口成员默认就是“open”的 fun b() &#123; print("b") &#125;&#125;class C() : A(), B &#123; // 编译器要求覆盖 f()： override fun f() &#123; super&lt;A&gt;.f() // 调用 A.f() super&lt;B&gt;.f() // 调用 B.f() &#125;&#125; 同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义。 抽象类类和其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。 我们可以用一个抽象成员覆盖一个非抽象的开放成员 1234567open class Base &#123; open fun f() &#123;&#125;&#125;abstract class Derived : Base() &#123; override abstract fun f()&#125; 伴生对象与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。 如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。 更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以使用像在 Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。 属性与字段属性与字段 接口使用关键字 interface 来定义接口 接口继承一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现： 1234567891011121314151617interface Named &#123; val name: String&#125;interface Person : Named &#123; val firstName: String val lastName: String override val name: String get() = "$firstName $lastName"&#125;data class Employee( // 不必实现“name” override val firstName: String, override val lastName: String, val position: Position) : Person 可见性修饰符类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public。 如果没有显式指定修饰符的话，默认可见性是 public。 包函数、属性和类、对象和接口可以在顶层声明，即直接在包内： 如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见； 如果你声明为 private，它只会在声明它的文件内可见； 如果你声明为 internal，它会在相同模块内随处可见； protected 不适用于顶层声明。 注意：要使用另一包中可见的顶层声明，仍需将其导入进来。 类和接口对于类内部声明的成员： private 意味着只在这个类内部（包含其所有成员）可见； protected—— 和 private一样 + 在子类中可见。 internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员； public —— 能见到类声明的任何客户端都可见其 public 成员。 注意 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员。 构造函数要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）： 1class C private constructor(a: Int) &#123; …… &#125; 这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见). 局部声明局部变量、函数和类不能有可见性修饰符。 模块可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件： 一个 IntelliJ IDEA 模块； 一个 Maven 项目； 一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）； 一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。 扩展Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。 扩展函数声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 扩展是静态解析的扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。 我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如： 123456789101112131415open class Cclass D: C()fun C.foo() = "c" // 扩展fun D.foo() = "d" // 扩展fun printFoo(c: C) &#123; println(c.foo())&#125;printFoo(D())这个例子会输出 "c"，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。 如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字并且都适用给定的参数，这种情况总是取成员函数。 例如：1234567class C &#123; fun foo() &#123; println("member") &#125;&#125;fun C.foo() &#123; println("extension") &#125;如果我们调用 C 类型 c的 c.foo()，它将输出“member”，而不是“extension”。 可空接收者注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。 123456fun Any?.toString(): String &#123; if (this == null) return "null" // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString() // 解析为 Any 类的成员函数 return toString()&#125; 扩展属性和函数类似，Kotlin 支持扩展属性： 12val &lt;T&gt; List&lt;T&gt;.lastIndex: Int get() = size - 1 伴生对象的扩展如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性： 1234567class MyClass &#123; companion object &#123; &#125; // 将被称为 "Companion"&#125;fun MyClass.Companion.foo() &#123; // ……&#125; 就像伴生对象的其他普通成员，只需用类名作为限定符去调用他们 1MyClass.foo() 扩展的作用域扩展的作用域 数据类我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data： 复制在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。 1234fun copy(name: String = this.name, age: Int = this.age) = User(name, age)val jack = User(name = "Jack", age = 1)val olderJack = jack.copy(age = 2) 数据类和解构声明为数据类生成的 Component 函数 使它们可在解构声明中使用： 123val jane = User("Jane", 35)val (name, age) = janeprintln("$name, $age years of age") // 输出 "Jane, 35 years of age" 密封类密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。 要声明一个密封类，需要在类名前面添加 sealed 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。 1234sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr() （上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。 ） 一个密封类是自身抽象的，它不能直接实例化并可以有抽象（abstract）成员。 密封类不允许有非 - private 构造函数（其构造函数默认为 private）。 请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。 使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。 123456fun eval(expr: Expr): Double = when(expr) &#123; is Const -&gt; expr.number is Sum -&gt; eval(expr.e1) + eval(expr.e2) NotANumber -&gt; Double.NaN // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin笔记-基础]]></title>
    <url>%2F2018%2FKotlin%2FKotlin%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Kotlin 语法基础 基本类型在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数和属性。 一些类型可以有特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。 表示方式在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 Int? ）或泛型。 后者情况下会把数字装箱。 注意数字装箱不必保留同一性: 12345val a: Int = 10000print(a === a) // 输出“true”val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA === anotherBoxedA) // ！！！输出“false”！！！ 另一方面，它保留了相等性: 12345val a: Int = 10000print(a == a) // 输出“true”val boxedA: Int? = aval anotherBoxedA: Int? = aprint(boxedA == anotherBoxedA) // 输出“true” 显式转换由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题： 1234// 假想的代码，实际上并不能编译：val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long 所以相等性会在所有地方悄无声息地失去，更别说同一性了。 因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。 12val b: Byte = 1 // OK, 字面值是静态检测的val i: Int = b // 错误 我们可以显式转换来拓宽数字 1val i: Int = b.toInt() // OK: 显式拓宽 每个数字类型支持如下的转换: toByte(): Byte toShort(): Short toInt(): Int toLong(): Long toFloat(): Float toDouble(): Double toChar(): Char 缺乏隐式类型转换并不显著，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如： 1val l = 1L + 3 // Long + Int =&gt; Long 运算Kotlin支持数字运算的标准集，运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。 对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如: 1val x = (1 shl 2) and 0x000FF000 这是完整的位运算列表（只用于 Int 和 Long）： shl(bits) – 有符号左移 (Java 的 &lt;&lt;) shr(bits) – 有符号右移 (Java 的 &gt;&gt;) ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;) and(bits) – 位与 or(bits) – 位或 xor(bits) – 位异或 inv() – 位非 数组数组在 Kotlin 中使用 Array 类来表示，它定义了 get 和 set 函数（按照运算符重载约定这会转变为 []）和 size 属性，以及一些其他有用的成员函数： 12345678class Array&lt;T&gt; private constructor() &#123; val size: Int operator fun get(index: Int): T operator fun set(index: Int, value: T): Unit operator fun iterator(): Iterator&lt;T&gt; // ……&#125; 我们可以使用库函数 arrayOf() 来创建一个数组并传递元素值给它，这样 arrayOf(1, 2, 3) 创建了 array [1, 2, 3]。 或者，库函数 arrayOfNulls() 可以用于创建一个指定大小的、所有元素都为空的数组。 另一个选项是用接受数组大小和一个函数参数的 Array 构造函数，用作参数的函数能够返回给定索引的每个元素初始值： 12// 创建一个 Array&lt;String&gt; 初始化为 [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]val asc = Array(5, &#123; i -&gt; (i * i).toString() &#125;) 注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 Array&lt;String&gt; 赋值给 Array&lt;Any&gt;，以防止可能的运行时失败（但是你可以使用 Array&lt;out Any&gt;, 参见类型投影）。 Kotlin 也有无装箱开销的专门的类来表示原生类型数组: ByteArray、 ShortArray、IntArray 等等。这些类和 Array 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法: 12val x: IntArray = intArrayOf(1, 2, 3)x[0] = x[1] + x[2] 字符串字符串用 String 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: s[i]。 可以用 for 循环迭代字符串: 请注意，在大多数情况下，优先使用 字符串模板 或 原始字符串 而不是字符串连接。 字符串字面值Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，以及原始字符串可以包含换行和任意文本。 原始字符串 使用三个引号（&quot;&quot;&quot;）分界符括起来，内部 没有转义 并且可以包含换行和任何其他字符: 123456789//输入值val text = &quot;&quot;&quot; for (c in &quot;foo&quot;) print(c)&quot;&quot;&quot;//输出值 for (c in &quot;foo&quot;) print(c) 你可以通过 trimMargin() 函数去除前导空格： 12345678910111213//输入值val text = &quot;&quot;&quot; |Tell me and I forget. Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) &quot;&quot;&quot;.trimMargin()//输出值Tell me and I forget. Teach me and I remember.Involve me and I learn.(Benjamin Franklin) 默认 | 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 trimMargin(&quot;&gt;&quot;)。 字符串模板字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（$）开头，由一个简单的名字构成: 原始字符串和转义字符串内部都支持模板。 如果你需要在原始字符串中表示字面值 $ 字符（它不支持反斜杠转义），你可以用下列语法： 1234567//输入值val price = &quot;&quot;&quot;$&#123;&apos;$&apos;&#125;9.99&quot;&quot;&quot;//输出值$9.99 包默认导入有多个包会默认导入到每个 Kotlin 文件中： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* （自 1.1 起） kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 根据目标平台还会导入额外的包： JVM: java.lang.* kotlin.jvm.* JS: kotlin.js.* 导入如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义： 12import foo.Bar // Bar 可访问import bar.Bar as bBar // bBar 代表“bar.Bar” 关键字 import 并不仅限于导入类；也可用它来导入其他声明： 顶层函数及属性； 在对象声明中声明的函数和属性; 枚举常量。 与 Java 不同，Kotlin 没有单独的“import static”语法； 所有这些声明都用 import 关键字导入。 顶层声明的可见性如果顶层声明是 private 的，它是声明它的文件所私有的（参见 可见性修饰符）。 控制流If 表达式if的分支可以是代码块，最后的表达式作为该块的值： 1234567val max = if (a &gt; b) &#123; print(&quot;Choose a&quot;) a&#125; else &#123; print(&quot;Choose b&quot;) b&#125; 如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支。 When 表达式when 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。） 如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］。 如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔： 1234when (x) &#123; 0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;) else -&gt; print(&quot;otherwise&quot;)&#125; 我们可以用任意表达式（而不只是常量）作为分支条件 我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中： 另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需任何额外的检测。 when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支： For 循环一些例子 1234567891011121314151617181920212223for (item in collection) print(item)for (item: Int in ints) &#123; // ……&#125;for (i in 1..3) &#123; println(i)&#125;for (i in 6 downTo 0 step 2) &#123; println(i)&#125;val array = arrayOf("a", "b", "c")for (i in array.indices) &#123; println(array[i])&#125;val array = arrayOf("a", "b", "c")for ((index, value) in array.withIndex()) &#123; println("the element at $index is $value")&#125; 返回和跳转Kotlin 有三种结构化跳转表达式： return。默认从最直接包围它的函数或者匿名函数返回。 break。终止最直接包围它的循环。 continue。继续下一次最直接包围它的循环。 所有这些表达式都可以用作更大表达式的一部分： 1val s = person.name ?: return 这些表达式的类型是 Nothing 类型。 Break 与 Continue 标签在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。 现在，我们可以用标签限制 break 或者continue： 123456loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop //表示跳出整个循环 if (……) continue@loop //表示继续loop循环的下一次迭代，既i++ &#125;&#125; 标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 continue 继续标签指定的循环的下一次迭代。 标签处返回例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//直接退出循环fun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return // 非局部直接返回到 foo() 的调用者 print(it) &#125; println("this point is unreachable")//不会输出&#125;输出：12//continuefun foo() &#123; listOf(1, 2, 3, 4, 5).forEach lit@&#123; if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环 print(it) &#125; print(" done with explicit label")&#125;输出：1245 done with explicit label//隐式标签 continuefun foo() &#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@forEach // 局部返回到该 lambda 表达式的调用者，即 forEach 循环 print(it) &#125; print(" done with explicit label")&#125;输出：1245 done with explicit label//用匿名函数代替 lambda 表达式 continuefun foo() &#123; listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) &#123; if (value == 3) return // 局部返回到匿名函数的调用者，即 forEach 循环 print(it) &#125;) print(" done with anonymous function")&#125;输出：1245 done with anonymous functionfun foo() &#123; run loop@&#123; listOf(1, 2, 3, 4, 5).forEach &#123; if (it == 3) return@loop // 从传入 run 的 lambda 表达式非局部返回 print(it) &#125; &#125; print(" done with nested loop")&#125;输出：12 done with nested loop 当要返一个回值的时候，解析器优先选用标签限制的 return，即 1return@a 1 意为“从标签 @a 返回 1”，而不是“返回一个标签标注的表达式 (@a 1)”。]]></content>
      <categories>
        <category>Android</category>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀开源项目记录]]></title>
    <url>%2F2018%2FAndroid%2F%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一款采用MVP模式的设计的仿造腾讯漫画的APPhttps://github.com/zhhr1122/z_comic_new WanAndroid客户端Flutter版https://github.com/canhuah/WanAndroid 在编写该案例过程中，遇到的一些问题，作者也做了总结： http://www.canhuah.com/Flutter实战之WanAndroid项目中碰到的问题.html 基于Flutter的开源中国客户端https://github.com/yubo725/flutter-osc 超完整开源Flutter Github客户端https://github.com/CarGuo/GSYGithubAppFlutter Android 骨架屏实现https://github.com/sharish/ShimmerRecyclerView https://github.com/ethanhua/Skeleton]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC机制（下）]]></title>
    <url>%2F2018%2FAndroid%2FIPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记下篇 Android 中的 IPC 方式BundleActivity、Service、Receiver 都是支持在 Intent 中传递 Bundle 数据的。例如相机 使用文件共享将某些类序列化成文件存储，通过文件共享信息 其中使用 SharedPreferences 需要注意，SharedPreferences 是 Android 中采用的轻量级存储方案，它底层通过 XML 文件来存储键值对。但是，由于系统对其读写有一定的缓存策略，即内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，其工作不可靠，面对高并发的读写访问，SharedPreferences 有可能会丢失数据。 使用 Messenger 信使一种轻量级的 IPC 方案，底层实现为 AIDL。 服务端：构建包含 Handler 的 Messenger ，在 Handler 里面对 Message 进行处理。通过 onBind 返回一个包含服务端调用的 Binder 对象。 客户端：在 onServiceConnected(ComponentName className, IBinder service) 中拿到服务端的调用 mService = new Messenger(service)， Messenger(IBinder service) 内部实现为 IMessenger.Stub.asInterface(service) 若客户端需要对服务端的通信做出回应，则在发送的时候构建处理返回消息的 Messenger，并在通过 msg.replyto = mMessenger 赋值在传送过去的 Message 对象中，服务端通过获取 msg.replyto 重新获取 Messenger 对象，并对其进行操作，从而完成客户端与服务端之间的通信。 使用 AIDLMessenger 的作用主要是为了传递消息，而很多时候我们需要跨进程调用服务端的方法，这种情况下 Messenger 无法做到，但是我们可以通过 AIDL 来实现跨进程的方法调用。AIDL 也是 Messenger 的底层实现。 服务端服务端首先要创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。 客户端首先需要绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转换成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法。 AIDL 接口的创建支持类型如下 基本数据类型（int、long、char、boolean、double等） String 和 CharSequence List：只支持 ArrayList，里面每个元素都必须能够被 AIDL 支持 Map：只支持 HashMap，里面每个元素都必须能够被 AIDL 支持，包括 key 和 value Parcelable：所有实现了 Parcelable 接口的对象 AIDL：所有的 AIDL 接口本身也可以在 AIDL 文件中使用 其中自定义的 Parcelable 对象和 AIDL 对象必须要显示 import 进来，不管是否在同一个包中。如果 AIDL 文件中用到了自定义的 Parcelable 对象，那么必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。除此之外，AIDL 中除了基本数据类型，其他类型的参数必须标上方向： in、out、inout 用以表示数据流向 服务端和客户端的实现简单的 C/S 模式下，AIDL 中 List 数据的传递，我们在 Service 中采用 CopyOnWriteArrayList 来完成，它支持并发读/写。我们知道 AIDL 方法是在服务端的 Binder 线程池中执行的 ，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在 AIDL 方法中处理线程同步，而 CopyOnWriteArrayList 能帮我们进行自动的线程同步。 前面我们提过 AIDL 中能够使用的 List 只有 ArrayList，但是我们这里却使用 CopyOnWriteArrayList （它并不继承于 ArrayList）。Binder 中会按照 List 的规范去访问数据并最终形成一个新的 ArrayList 传递给客户端。与此类似的还有 ConcurrentHashMap。 我们还可以使用 AIDL 接口，完成观察者模式。对应的应用例如系统服务的监听（定位…） 对象的跨进程传输本质都是反序列化的过程，所以 AIDL 中自定义对象都必须要实现 Parcelable 接口。RemoteCallbackList 是系统专门提供的用于删除跨进程 listenr 的接口。RemoteCallbackList 是一个泛型，支持管理任意 AIDL 接口。当客户端进程终止后，它能够自动移除客户端所注册的 listener，且内部实现了线程同步的功能。遍历 RemoteCallbackList 需要如下方式 123456789101112final int N = mListenerList.beginBroadcast(); for (int i = 0; i &lt; N; i++) &#123; IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i); if (listener != null)&#123; try &#123; listener.onNewBookArrived(book); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125; &#125; mListenerList.finishBroadcast(); AIDL 特别点 客户端调用远程服务的方法，被调用的方法运行在 Binder 线程池中，所以服务端本身可以执行大量耗时的操作。客户端线程在调用的时候会被挂起，所以调用耗时服务端方法时需另开线程完成。 客户端的 onServiceConnected 和 onServiceDisconnected 方法都运行在 UI 线程中，不要在其中调用服务端的耗时方法，否则会导致 ANR。 服务端同样不能调用客户端中的耗时方法 服务端调用客户端的方法，客户端的方法运行在客户端的 Binder 线程池中，所以不能在里面去访问 UI 相关的内容，需使用 Handler 切换到 UI 线程。 Binder 死亡处理方法一：通过 DeathRecipient 监听，在 binderDied 方法中重连，具体内容见上篇。（binderDied 在客户端的 Binder 线程池中被回调） 方法二：在 onServiceDisconnected 中重连远程服务。（在客户端的 UI 线程中被回调） AIDL 权限验证 定义 permission 123&lt;permission android:name="chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; 使用 permission 1&lt;uses-permission android:name="chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE" /&gt; 服务端 onBind 验证 permission 12345678910@Overridepublic IBinder onBind(Intent intent) &#123; //验证权限 int check = checkCallingOrSelfPermission("chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE"); //未授权 if (check == PackageManager.PERMISSION_DENIED)&#123; return null; &#125; return mBinder;&#125; 使用 ContentProvider通过数据库的方式进行进程间通信 SocketBinder 连接池通过创建一个 Service 即可完成多个 AIDL 接口的工作]]></content>
      <categories>
        <category>Android</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android 开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC 机制（上）]]></title>
    <url>%2F2018%2FAndroid%2FIPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记上篇 简介IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程直接进行数据交换的过程。 Android 中的多进程模式开启多进程模式给四大组件在 AndroidMenifest 中指定 android:process 属性，除此之外没有其他办法，也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。另：非常规方式，通过 JNI 在 native 层去 fork 一个新的进程。 12345678910111213&lt;!-- 包名加":remote"--&gt;&lt;!-- 属于当前应用的私有进程 --&gt;&lt;!-- 其他应用不可以和他跑在同一个进程中 --&gt;&lt;activity android:name=".activity.TestActivity1" android:process=":remote" /&gt;&lt;!-- 完整进程名--&gt;&lt;!-- 全局进程 --&gt;&lt;!-- 其他应用可以通过 ShareUID 方式可以和它跑在同一个进程中 --&gt;&lt;activity android:name=".activity.TestActivity2" android:process="com.chennuo.remote" /&gt; 可以通过 adb shell ps 命令来查看进程信息 我们知道 Android 系统会为每个应用分配一个唯一的 UID， 具有相同 UID 的应用才能共享数据。这里要说明的是，两个应用通过 ShareUID 跑在同一个进程中是有要求的，需要这两个应用有相同的 ShareUID 并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如 data 目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享 data 目录、组件信息，还可以共享内存数据，或者它们看起来就像是一个应用的两个部分。 多进程模式的运行机制一般来说，使用多进程会造成如下几方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences 的可靠性下降 Application 会多次创建 IPC 基础概念介绍Serializable 接口 声明 serialVersionUID 非必须，但是不声明 serialVersionUID 会对反序列化过程带来影响。 序列化的时候，系统会把当前类的 serialVersionUID 写入序列化的文件中（也可能是其他的中介），当反序列化的时候，系统会去检测文件中的 serialVersionUID ，看是否和当前类的一致。如果一致则说明两者版本相同。否则，说明当前类和序列化的类发生了某些变换，会报 java.io.InvalidClassException 错误 我们可以给 serialVersionUID 指定为 1L 或者由 AS 自动生成 serialVersionUID 的 hash 值，两者没有本质区别。 注： 1.静态成员变量属于类不属于对象，所以不会参与序列化过程 2.用 transient 关键字标记的成员变量不参与序列化过程 Parcelable 接口 Serializable 是 Java 中的序列化接口，其使用简单但是开销大，序列化和反序列化都需要大量的 I/O 操作。Parcelable 是 Android 中的序列化方式，更适合用于 Android 平台。对比两者，Parcelable 主要用于内存序列化上。Serializable 更适合将序列化到存储设备或者将对象序列化后通过网络传输。 BinderAndroid 开发中，Binder 主要用在 Service 中，包括 AIDL 和 Messenger，其中普通 Service 中的 Binder 不涉及进程间通信，而 Messenger 的底层其实是 AIDL。所以我们选择用 AIDL 来分析 Binder 的工作机制。 分析 AIDL当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的 transact 过程，而当两者位于不同的进程时，方法调用需要走 transact 过程，这个逻辑由 Stub 的内部代理类 Proxy 来完成。这个接口的核心实现就是它的内部类 Stub 和 Stub 的内部代理类 Proxy。 DESCRIPTORBinder 的唯一标识，一般用当前 Binder 的类名表示。 asInterface(android.os.IBinder obj)用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的。如果两端位于同一进程，则返回服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象 1234567891011121314/** * Cast an IBinder object into an chen.easyview.aidl.IBookManager interface, * generating a proxy if needed. */public static chen.easyview.aidl.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof chen.easyview.aidl.IBookManager))) &#123; return ((chen.easyview.aidl.IBookManager) iin); &#125; return new chen.easyview.aidl.IBookManager.Stub.Proxy(obj);&#125; asBinder用于返回当前 Binder 对象 onTransact该方法运行在服务端中的 Binder 线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。如果此方法返回 false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证 1234567891011121314151617181920212223242526272829@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;chen.easyview.aidl.Book&gt; _result = this.getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); chen.easyview.aidl.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = chen.easyview.aidl.Book.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; Proxy#getBookList 12345678910111213141516@Overridepublic java.util.List&lt;chen.easyview.aidl.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;chen.easyview.aidl.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(chen.easyview.aidl.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 这个方法运行在客户端，当客户端远程调用此方法时，会调用 transact 方法来发起 RPC（远程过程调用） 请求，同时当前线程挂起；然后服务端的 onTransact 方法会被调用，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据、 自己写 AIDLAIDL 不是实现 Binder 的必需品。如果是我们手写的 Binder，那么在服务端只需要创建一个 BookManagerImpl 的对象并在 Service 的 onBind 方法中返回即可。 Binder 的两个重要方法 linkToDeath unlinkTODeath 这两个方法用于监听 Binder 连接是否断裂。 通过 linkToDeath 我们可以给 Binder 设置一个死亡代理，当 Binder 死亡时，我们就会收到通知。首先，我们声明一个 DeathRecipient 对象，其为接口，内部只有一个方法 binderDied，我们需要实现这个方法，当 Binder 死亡的时候，系统就会回调 binderDied 方法，然后我们就可以移除之前绑定的 binder 代理并重新绑定远程服务。 1234567891011121314151617181920212223242526272829303132333435// 写在客户端中 IBookManager mBookManager; private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; if(mBookManager == null)&#123; return; &#125; mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0); mBookManager = null; bindService(new Intent("chen.easyview.aidl.IBookManager").setPackage("chen.easyview") ,conn, BIND_AUTO_CREATE); &#125; &#125;; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBookManager = IBookManager.Stub.asInterface(service); try &#123; service.linkToDeath(mDeathRecipient,0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;// 另通过 Binder 的方法 isBinderAlive 也可以判断 Binder 是否死亡。 以上为 IPC 的基础知识，下篇将继续记录 Android 中的进程间通信]]></content>
      <categories>
        <category>Android</category>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>Android 开发艺术探索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity四种启动模式]]></title>
    <url>%2F2017%2FAndroid%2FActivity%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在 Activity 的多 Activity 开发中，Activity 之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个 Activity 实例，而不是生成大量的重复的 Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个 Activity 实例。在 Activity 里，有 4 种 Activity 的启动模式，分别为： standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。在这种模式下，activity默认会进入启动它的activity所属的任务栈中。注意：在非activity类型的context (如 ApplicationContext )并没有所谓的任务栈，所以不能通过ApplicationContext去启动standard模式的activity。 singleTop: 栈顶复用模式。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。注意：这个activity的onCreate，onStart，onResume不会被回调，因为他们并没有发生改变。 singleTask: 栈内复用模式。首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈。 如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去。 如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例 。 如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法。 如果不存在该实例，则新建Activity，并入栈 singleInstance: 这个跟singleTask基本上是一样，只有一个区别：这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 应用场景 standard：默认启动模式 singleTop: 当且仅当启动的 Activity 和上一个 Activity 一致的时候才会通过调用onNewIntent()方法重用 Activity。使用场景：资讯阅读类 APP 的内容界面。 singleTask：浏览器的主页面，或者大部分 APP 的主页面。 这些启动模式可以在功能清单文件AndroidManifest.xml中进行设置，中的launchMode属性。相关的代码中也有一些标志可以使用,比如我们想只启用一个实例,则可以使用 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 标志，这个标志表示：如果这个activity已经启动了，就不产生新的activity，而只是把这个activity实例加到栈顶来就可以了。 123Intent intent = new Intent(ReorderFour.this, ReorderTwo.class);intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);startActivity(intent); Activity的加载模式受启动Activity的Intent对象中设置的Flag和manifest文件中Activity的元素的特性值交互控制。 下面是影响加载模式的一些特性。核心的Intent Flag有： FLAG_ACTIVITY_NEW_TASK FLAG_ACTIVITY_CLEAR_TOP FLAG_ACTIVITY_RESET_TASK_IF_NEEDED FLAG_ACTIVITY_SINGLE_TOP 核心的特性有： taskAffinity launchMode allowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch 四种加载模式的区别 所属task的区别 一般情况下，standard 和 singleTop 的 activity 的目标task，和收到的 Intent 的发送者在同一个 task 内，就相当于谁调用它，它就跟谁在同一个Task中。除非Intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。singleTask 和 singleInstance 总是把要启动的 activity 作为一个 task 的根元素，他们不会被启动到一个其他 task 里。 是否允许多个实例 standard 和 singleTop 可以被实例化多次，并且是可以存在于不同的 task 中；这种实例化时一个 task 可以包括一个 activity 的多个实例； singleTask 和 singleInstance 则限制只生成一个实例，并且是 task 的根元素。 singleTop 要求如果创建intent的时候栈顶已经有要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。 是否允许其它activity存在于本task内 singleInstance 独占一个 task，其它 activity 不能存在那个 task 里；如果它启动了一个新的 activity，不管新的 activity 的 launch mode 如何，新的 activity 都将会到别的 task 里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。 而另外三种模式，则可以和其它activity共存。 是否每次都生成新实例 standard 对于每一个启动 Intent 都会生成一个 activity 的新实例； singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。比如：现在task栈元素为A - B - C - D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D 如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。 singleInstance 是其所在栈的唯一activity，它会每次都被重用。 singleTask” 如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。 当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法，如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。]]></content>
      <categories>
        <category>Android</category>
        <category>四大组件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity 基本介绍]]></title>
    <url>%2F2017%2FAndroid%2FActivity%2F</url>
    <content type="text"><![CDATA[内容包括 启动顺序 生命周期 三个时期 Activity 栈 Activity 状态 面试题 Activity启动顺序 第一个Activity启动时： onCreate()——&gt;onStart()——&gt;onResume() 当另一个Activity启动时: 第一个Activity onPause()——&gt;第二个Activity onCreate()——&gt;onStart()——&gt;onResume() ——&gt;第一个Activity onStop() 当返回到第一个Activity时： 第二个Activity onPause() ——&gt; 第一个Activity onRestart()——&gt;onStart()——&gt;onResume() ——&gt;第二个Activity onStop()——&gt;onDestroy() 一个Activity的销毁顺序:（情况一）onPause()——&gt;&lt;Process Killed&gt; （情况二）onPause()——&gt;onStop()——&gt;&lt;Process Killed&gt; （情况三）onPause()——&gt;onStop()——&gt;onDestroy() 但是当一个活动的状态发生改变的时候，开发者可以通过调用 onXX() 的方法获取到相关的通知信息。 在实现 Activity 类的时候，通过覆盖（ override ）这些方法即可在你需要处理的时候来调用。 生命周期 onCreate ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState （）方法保存的状态信息。 onStart ：该方法的触发表示所属活动将被展现给用户。活动由不可见变为可见的时候调用 onResume ：当一个活动和用户发生交互的时候，触发该方法。此时的活动一定位于返回栈的栈顶，并且处于运行状态。 onPause ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。我们通常会在这个方法中将一些及其消耗 CPU 的资源释放掉（比如显示地图或者大规模图形），以及保存一些关键数据（比如用户输入的数据等等），但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。 onStop ：当一个活动不再需要展示给用户的时候，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发 onStop 方法。 所以保存状态信息是应该在onPause时做，而不是onStop时做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。 onRestart ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。 onDestroy ：当活动销毁的时候，触发该方法。和 onStop 方法一样，如果内存紧张，系统会直接结束这个活动而不会触发该方法。 onSaveInstanceState：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，已经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。 三个时期 完整生存期 活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。 可见生存期划重点！！！这个问题我就在面试中遇到了，其实我知晓这个题，怎奈误解了面试官的意思答非所问了。活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。在可见生存期内， 活动对于用户总是可见的， 即便有可能无法和用户进行交互。 我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放， 从而保证处于停止状态的活动不会占用过多内存。 前台生存期活动在onResume()方法和onPause()方法之间所经历的，就是前台生存期。在前台生存期内， 活动总是处于运行状态的， 此时的活动是可以和用户进行相互的， 我们平时看到和接触最多的也这个状态下的活动。 Activity 栈上面提到开发者是无法控制Activity的状态的，那Activity的状态又是按照何种逻辑来运作的呢？这就要知道 Activity 栈。每个Activity的状态是由它在Activity栈（是一个后进先出LIFO，包含所有正在运行Activity的队列）中的位置决定的。当一个新的Activity启动时，当前的活动的Activity将会移到Activity栈的顶部。如果用户使用后退按钮返回的话，或者前台的Activity结束，活动的Activity就会被移出栈消亡，而在栈上的上一个活动的Activity将会移上来并变为活动状态。一个应用程序的优先级是受最高优先级的Activity影响的。当决定某个应用程序是否要终结去释放资源，Android内存管理使用栈来决定基于Activity的应用程序的优先级。 Activity状态一般认为Activity有以下四种状态： 活动的：当一个Activity在栈顶，它是可视的、有焦点、可接受用户输入的。Android试图尽最大可能保持它活动状态，杀死其它Activity来确保当前活动Activity有足够的资源可使用。当另外一个Activity被激活，这个将会被暂停。 暂停：在很多情况下，你的Activity可视但是它没有焦点，换句话说它被暂停了。有可能原因是一个透明或者非全屏的Activity被激活。当被暂停，一个Activity仍会当成活动状态，只不过是不可以接受用户输入。在极特殊的情况下，Android将会杀死一个暂停的Activity来为活动的Activity提供充足的资源。当一个Activity变为完全隐藏，它将会变成停止。 停止：当一个Activity不是可视的，它“停止”了。这个Activity将仍然在内存中保存它所有的状态和会员信息。尽管如此，当其它地方需要内存时，它将是最有可能被释放资源的。当一个Activity停止后，一个很重要的步骤是要保存数据和当前UI状态。一旦一个Activity退出或关闭了，它将变为待用状态。 待用： 在一个Activity被杀死后和被装在前，它是待用状态的。待用Acitivity被移除Activity栈，并且需要在显示和可用之前重新启动它。 面试题： Activity A 通过 Intent 显示启动了 Activity B，当 B 处于可见状态后，A 是否一定会调用onStop()? 不一定，有可能A此时仍然可见，例如B是一个DialogActivity，或者其他A仍可见的情况。]]></content>
      <categories>
        <category>Android</category>
        <category>四大组件</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Server]]></title>
    <url>%2F2017%2FAndroid%2FServer%2F</url>
    <content type="text"><![CDATA[Service可以在和多场合的应用中使用，比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放，比如检测SD卡上文件的变化，再或者在后台记录你地理信息位置的改变等等，总之服务嘛，总是藏在后头的。 Service是在一段不定的时间运行在后台，不和用户交互应用组件。每个Service必须在manifest中 通过&lt;service&gt;来声明。可以通过contect.startservice和contect.bindserverice来启动。 Service和其他的应用组件一样，运行在进程的主线程中。这就是说如果service需要很多耗时或者阻塞的操作，需要在其子线程中实现。 启动方式不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。使用context.startService() 启动Service时会经历: context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running context.stopService() | -&gt;onDestroy() -&gt;Service stop 如果Service还没有运行，则android先调用onCreate()然后调用onStart()；如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。 stopService的时候直接onDestroy，如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。 所以调用startService的生命周期为：onCreate –&gt; onStart(可多次调用) –&gt; onDestroy 特点：一旦服务开启就跟调用者（开启者）没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行，开启者不能调用服务里面的方法。 使用context.bindService() 启动Service时会经历: context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running onUnbind() -&gt; onDestroy() -&gt;Service stop onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候把调用者（Context，例如Activity）会和Service绑定在一起，Context退出了，Srevice就会调用onUnbind-&gt;onDestroy相应退出。 所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。 在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。 特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。 service的两种模式（startService()/bindService()不是完全分离的）本地服务 Local Service 用于应用程序内部。它可以启动并运行，直至有人停止了它或它自己停止。在这种方式下，它以调用Context.startService()启动，而以调用Context.stopService()结束。它可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。用于实现应用程序自己的一些耗时任务，比如查询升级信息，并不占用应用程序比如Activity所属线程，而是单开线程后台执行，这样用户体验比较好。 调用者和service在同一个进程里，所以运行在主进程的main线程中。所以不能进行耗时操作，可以采用在service里面创建一个Thread来执行任务。service影响的是进程的生命周期，讨论与Thread的区别没有意义。任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service的实例。 远程服务 Remote Service 用于android系统内部的应用程序之间。它可以通过自己定义并暴露出来的接口进行程序操作。客户端建立一个到服务对象的连接，并通过那个连接来调用服务。连接以调用Context.bindService()方法建立，以调用 Context.unbindService()关闭。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。 调用者和service不在同一个进程中，service在单独的进程中的main线程，是一种垮进程通信方式 IntentServiceIntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题： Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中； Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务； IntentService特征: 会创建独立的worker线程来处理所有的Intent请求； 会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题； 所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service； 为Service的onBind()提供默认实现，返回null； 为Service的onStartCommand提供默认实现，将请求Intent添加到队列中； 参考资料：https://www.jianshu.com/p/51aaa65d5d25]]></content>
      <categories>
        <category>Android</category>
        <category>四大组件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Permission]]></title>
    <url>%2F2017%2FAndroid%2FPermission%2F</url>
    <content type="text"><![CDATA[6.0 动态权限申请，自己封装使用的一个 Activity 配置方式 Activity 设置透明背景 android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot; 暂时仅设置每次申请一种权限 使用方式123if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123; PermissionActivity.startNewActivity(context, Manifest.permission.WRITE_EXTERNAL_STORAGE);&#125; Activity 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338public class PermissionActivity extends Activity &#123; public static final String PERMISSION = "PERMISSION"; private static final int REQUEST_Code = 2017; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_permission); isImmersive = false; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; setTranslucentStatus(true); &#125; //为状态栏着色 SystemBarTintManager tintManager = new SystemBarTintManager(this); tintManager.setStatusBarTintEnabled(true); tintManager.setStatusBarTintColor(Color.TRANSPARENT); KLog.e(Build.FINGERPRINT); findViewById(R.id.background).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); String mPermission = getIntent().getStringExtra(PERMISSION); if (!TextUtil.isValidate(mPermission)) return; checkPermission(mPermission, REQUEST_Code); &#125; private void checkPermission(String permission, int requestCode) &#123; switch (PermissionChecker.checkSelfPermission(PermissionActivity.this, permission)) &#123; case PermissionChecker.PERMISSION_GRANTED: KLog.e(permission + " 已申请"); switch (permission) &#123; case Manifest.permission.ACCESS_COARSE_LOCATION: if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//这个需要版本号大于19 AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); int checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_COARSE_LOCATION, android.os.Process.myUid(), getPackageName()); checkAppOpsManager(permission, checkOp); &#125; break; case Manifest.permission.ACCESS_FINE_LOCATION: if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//这个需要版本号大于19 AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); int checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_FINE_LOCATION, android.os.Process.myUid(), getPackageName()); checkAppOpsManager(permission, checkOp); &#125; break; case Manifest.permission.READ_CONTACTS: if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//这个需要版本号大于19 AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; int checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_READ_CONTACTS, android.os.Process.myUid(), getPackageName()); checkAppOpsManager(permission, checkOp); &#125; &#125; break; default: break; &#125; checkAppOpsManagerCompat(permission); finish();// Intent intent = new Intent("android.content.pm.action.REQUEST_PERMISSIONS");// intent.putExtra("android.content.pm.extra.REQUEST_PERMISSIONS_NAMES", permission);// startActivity(intent); break; case PermissionChecker.PERMISSION_DENIED: checkShowRequestPermissionRationale("未申请", permission, requestCode); break; case PermissionChecker.PERMISSION_DENIED_APP_OP: checkShowRequestPermissionRationale("APP_OP未申请", permission, requestCode); break; default: KLog.e(PermissionChecker.checkSelfPermission(PermissionActivity.this, permission)); checkShowRequestPermissionRationale("error", permission, requestCode); ActivityCompat.requestPermissions(PermissionActivity.this, new String[]&#123;permission&#125;, requestCode); &#125; &#125; void checkShowRequestPermissionRationale(String starte, final String permission, final int requestCode) &#123; KLog.e(permission + ":" + starte); if (shouldShowRequestPermissionRationale(PermissionActivity.this, permission)) &#123; KLog.e(starte + ":自定义弹窗"); Dialogbox_permission.newInstance(PermissionActivity.this) .setTitle("获取权限") .setContent(getString(permission)) .setCancel("残忍拒绝") .setOk("重新授权") .setOnCallback( new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; ActivityCompat.requestPermissions(PermissionActivity.this, new String[]&#123;permission&#125;, requestCode); dialogObject.dialog.cancel(); &#125; &#125; ) .setCancelOnCallback(new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; finish(); &#125; &#125;).show(); &#125; else &#123; KLog.e(starte + ":开始请求"); ActivityCompat.requestPermissions(PermissionActivity.this, new String[]&#123;permission&#125;, requestCode); &#125; checkAppOpsManagerCompat(permission); &#125; void checkAppOpsManager(String permission, int checkOp) &#123; switch (checkOp) &#123; case AppOpsManager.MODE_ALLOWED: KLog.e(permission + " MODE_ALLOWED"); break; case AppOpsManager.MODE_DEFAULT: KLog.e(permission + " MODE_DEFAULT"); break; case AppOpsManager.MODE_ERRORED: KLog.e(permission + " MODE_ERRORED"); break; case AppOpsManager.MODE_IGNORED: KLog.e(permission + " MODE_IGNORED"); break; default: KLog.e(permission + " MODE_DEFAULT: " + checkOp); &#125; &#125; void checkAppOpsManagerCompat(String permission) &#123; String permissionToOp = AppOpsManagerCompat.permissionToOp(permission); if (permissionToOp == null) &#123; KLog.e(permission + " permissionToOp 为 null 仍需要授权？需要 SDK &gt;= 23"); &#125; else &#123; KLog.e(permission + " permissionToOp 为 " + permissionToOp); int noteOp = AppOpsManagerCompat.noteOp(PermissionActivity.this, permissionToOp, android.os.Process.myUid(), getBaseContext().getPackageName()); switch (noteOp) &#123; case AppOpsManagerCompat.MODE_ALLOWED: KLog.e(permission + " AppOpsManagerCompat.MODE_ALLOWED"); KLog.e("-----------------------"); break; case AppOpsManagerCompat.MODE_DEFAULT: KLog.e(permission + " AppOpsManagerCompat.MODE_DEFAULT"); KLog.e("xxxxxxxxxxxxxxxxxxxxxxx"); break; case AppOpsManagerCompat.MODE_IGNORED: KLog.e("iiiiiiiiiiiiiiiiiiiiiii"); KLog.e(permission + " AppOpsManagerCompat.MODE_IGNORED");//小米在系统取消授权后，会调到这里，请求的回调都是成功，然而事实不是，考虑跳通知界面 break; default: KLog.e(permission + " AppOpsManagerCompat.MODE " + noteOp); &#125; &#125; &#125; @Override public void onRequestPermissionsResult(final int requestCode, @NonNull final String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (permissions == null || permissions.length &lt; 1) &#123; return; &#125; KLog.e("onRequestPermissionsResult:" + permissions[0]); switch (requestCode) &#123; case REQUEST_Code: if (verifyPermissions(grantResults)) &#123; KLog.e(Arrays.toString(permissions) + " 申请成功"); finish(); &#125; else &#123; if (PermissionActivity.shouldShowRequestPermissionRationale(PermissionActivity.this, permissions)) &#123; Dialogbox_permission.newInstance(PermissionActivity.this) .setTitle("获取权限") .setContent(getString(permissions[0])) .setCancel("残忍拒绝") .setOk("重新授权") .setOnCallback(new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; ActivityCompat.requestPermissions(PermissionActivity.this, permissions, requestCode); dialogObject.dialog.cancel(); &#125; &#125;) .setCancelOnCallback(new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; finish(); &#125; &#125;).show(); &#125; else &#123; Dialogbox_permission.newInstance(PermissionActivity.this) .setTitle("获取权限") .setContent(getString2(permissions[0])) .setCancel("我已了解") .setOk("前往设置") .setOnCallback(new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; startActivity(PermissionsPageManager.getIntent(PermissionActivity.this)); dialogObject.dialog.cancel(); &#125; &#125;) .setCancelOnCallback(new Dialogbox_permission.OnCallback() &#123; @Override public void callback(Dialogbox_permission.DialogObject dialogObject) &#123; finish(); &#125; &#125;) .show(); &#125; &#125; break; default: break; &#125; &#125; public static boolean verifyPermissions(int... grantResults) &#123; if (grantResults.length == 0) &#123; return false; &#125; for (int result : grantResults) &#123; if (result != PackageManager.PERMISSION_GRANTED) &#123; return false; &#125; &#125; return true; &#125; /** * Checks given permissions are needed to show rationale. * * @param activity activity * @param permissions permission list * @return returns true if one of the permission is needed to show rationale. */ public static boolean shouldShowRequestPermissionRationale(Activity activity, String... permissions) &#123; for (String permission : permissions) &#123; if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123; return true; &#125; &#125; return false; &#125; /** * Checks given permissions are needed to show rationale. * * @param fragment fragment * @param permissions permission list * @return returns true if one of the permission is needed to show rationale. */ public static boolean shouldShowRequestPermissionRationale(android.support.v4.app.Fragment fragment, String... permissions) &#123; for (String permission : permissions) &#123; if (fragment.shouldShowRequestPermissionRationale(permission)) &#123; return true; &#125; &#125; return false; &#125; private Spanned getString(String permission) &#123; if (!TextUtil.isValidate(permission)) &#123; return Html.fromHtml("完善App功能需要该权限"); &#125; switch (permission) &#123; case Manifest.permission.ACCESS_COARSE_LOCATION: case Manifest.permission.ACCESS_FINE_LOCATION: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;位置信息&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"); case Manifest.permission.CAMERA: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;相机&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"); case Manifest.permission.WRITE_EXTERNAL_STORAGE: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;SD卡&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常更新或使用XXX应用"); case Manifest.permission.READ_PHONE_STATE: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;读取设备信息&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常更新或使用XXX应用"); case Manifest.permission.READ_CONTACTS: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;读取联系人&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"); case Manifest.permission.RECORD_AUDIO: return Html.fromHtml("我们需要获取&lt;font color='#0378d8'&gt;麦克风&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"); default: return Html.fromHtml("完善App功能需要该权限"); &#125; &#125; private Spanned getString2(String permission) &#123; if (!TextUtil.isValidate(permission)) &#123; return Html.fromHtml("权限缺少将对体验造成较大影响"); &#125; switch (permission) &#123; case Manifest.permission.ACCESS_COARSE_LOCATION: case Manifest.permission.ACCESS_FINE_LOCATION: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;位置信息&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); case Manifest.permission.CAMERA: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;相机&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); case Manifest.permission.WRITE_EXTERNAL_STORAGE: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;SD卡&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); case Manifest.permission.READ_PHONE_STATE: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;读取设备信息&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); case Manifest.permission.READ_CONTACTS: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;读取联系人&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); case Manifest.permission.RECORD_AUDIO: return Html.fromHtml("由于无法获取&lt;font color='#0378d8'&gt;麦克风&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"); default: return Html.fromHtml("权限缺少将对体验造成较大影响"); &#125; &#125; public static void startNewActivity(Context context, String permission) &#123; Intent intent = new Intent(context, PermissionActivity.class); intent.putExtra(PERMISSION, permission); context.startActivity(intent); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>新特性</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android冷知识]]></title>
    <url>%2F2017%2FAndroid%2FAndroid%E5%86%B7%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一些在面试题中可能出现的冷知识持续更新 1、 Android应用的所有UI组件都继承了View类，View类还有一个重要的子类：VIewGroup，但ViewGroup通常作为其他组件的容器使用。 2、 ListView、GridView、Spinner、Gallery等AdapterView都只是容器，而Adapter负责提供每个“列表项”组件，AdapterView则负责采用合适的方式显示这些列表项。 3、 Android已经不推荐使用Gallery组件，推荐使用其他水平滚动组件HorizontalSorollView和ViewPager 4、 Android系统包含两套事件处理系统 基于监听的事件处理 沿袭Java方式有： 内部类形式：将事件监听器类定义成当前类的内部类 外部类形式：将事件监听器类定义成一个外部类 Activity本身作为事件监听器类：让Activity本身实现监听器接口，并实现事件处理方法 匿名内部类形式：使用匿名内部类创建事件监听器对象 Android方式有： 直接绑定到android界面组件标签 基于回调的事件处理 重写View控件，对回调函数进行处理 基于回调的事件传播 如果处理事情的回调方法返回true，则表明改处理方法已完全处理该事件，该事件不会传播出去。反之false则会继续传播下去 Button组件实践：Android系统最先触发的是Button上绑定的事件监听器，接着才触发该组件提供的事件的回调方法，然后还会传播到该组件所在的Activity。 顺序：事件监听器—&gt;组件回调方法—&gt; Activity 对比Android提供的两种事件处理模型，不难发现基于监听的事件处理模型具有更大的优势： 基于监听的事件模型分工更明确，事件源、事件监听由两个类分开实现，因此具有更好的可维护性。 Android的事件处理机制保证基于监听的事件监听器会被优先触发。 5、 Android的UI操作并不是线程安全的。故Android制定了一条简单的规则：只允许UI线程修改Activity里的UI组件。Android不允许在新的线程中访问Activity里面的界面组件。 6、若应用程序没有声明任何一个活动作为主活动，这个程序仍然可以正常安装。只是你无法在启动器中看到或者打开这个程序。这种程序一般作为第三方服务供其他应用在内部进行调用的，如支付宝快捷支付服务。 7、 在Manifest中对Activity进行theme定义，可将activity显示模式变成对话框形式。 123&lt;activity android:name=".xxxx" android:theme="@android:style/Theme.Dialog"&gt; 8、res/raw和assets 相同点 两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。 不同点 res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename； assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。 res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹 读取文件资源 读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作 InputStream is =getResources().openRawResource(R.id.filename); 读取assets下的文件资源，通过以下方式获取输入流来进行写操作 123AssetManager am = null;am = getAssets();InputStream is = am.open("filename"); 注 1：Google的Android系统处理Assert有个bug，在AssertManager中不能处理单个超过1MB的文件，不然会报异常，raw没这个限制可以放个4MB的Mp3文件没问题。 2：assets 文件夹是存放不进行编译加工的原生文件，即该文件夹里面的文件不会像 xml， java 文件被预编译，可以存放一些图片，html，js, css 等文件。 9、 Mipmap图像 APK分包时，mipmap资源会全部包含在APK文件中，所以Android推荐将启动器图标放进mipmap目录中]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发小技巧]]></title>
    <url>%2F2017%2FAndroid%2FAndroid%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些在工作中会遇到的好方法 知晓当前在哪个活动之中新建一个BaseActivity ，在OnCreate中加上 Log.e(“BaseActivity”, getClass().getSimpleName()); 随时随地退出程序新建一个ActivityCollector类作为活动的管理器 在Activity管理器中维护一个activity的列表，用于activity新建和销毁的记录，实现add和remove两个方法，并实现finishALl方法。 在BaseActivity的onCreated()中 ActivityCollector.add(this) 在onDestroy()中 ActivityCollector.remove(this) 在任意Activity中想退出程序都可以调用ActivityCollector.finishAll() 不够优雅，改为监听生命周期的方式 ActivityLifecycleCallbacks 启动活动的最佳写法在目标SecondActivity中写下如下方法 123456public static void activityStart(Context context, String data1, String data2,……)&#123; Intent intent = new Intent(context , SecondActivity.class); intent.putExtra("param1", data1); intent.putExtra("param2", data2); context.startActivity(intent);&#125; 在首FirstActivity中就可以通过 SecondActivity.activityStart(FirstActivity.this, “xxx” ,”xxx” ); 完成启动的写法。这样利于多人协作，调用其他人写的Activity时不用考虑传参细节。 Android 向上回退操作1234Intent intent = new Intent(this,xxx,class);intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);startActivity(intent);finish();]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文字混排]]></title>
    <url>%2F2017%2FAndroid%2F%E6%96%87%E5%AD%97%E6%B7%B7%E6%8E%92%2F</url>
    <content type="text"><![CDATA[ALinaCenterImageSpan在使用过程中，发现当ImageSpan设置基线对齐时，因为TextView设置了行间距例如android:lineSpacingExtra=”5dp”在6.0以下无法正常显示，故重写ImageSpan重新设置ImageSpan居中 参考链接 123456789101112131415161718public class AlignCenterImageSpan extends ImageSpan &#123; public AlignCenterImageSpan(Drawable d) &#123; super(d); &#125; @Override public void draw(Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; Paint.FontMetricsInt fm = paint.getFontMetricsInt(); Drawable b = getDrawable(); canvas.save(); int transY = (y + fm.descent + y + fm.ascent) / 2 - b.getBounds().bottom / 2;//计算y方向的位移 canvas.translate(x, transY); b.draw(canvas); canvas.restore(); &#125;&#125; 关键方法为 移动 图片位置的计算，目前看不懂 另，如果需要对图片添加点击事件，简单处理可以在相同位置添加 ClickSpan ，而且记得要对 TextView 的点击事件进行处理，配置如下方法 mTextView.setMovementMethod(LinkMovementMethod.getInstance());//解决点击冲突]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ViewPager + Fragment]]></title>
    <url>%2F2017%2FAndroid%2FViewPagerAndFragment%2F</url>
    <content type="text"><![CDATA[ViewPager 里对 Fragment 的相关优化操作FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别参考链接 基本使用ViewPager是support v4库中提供界面滑动的类，继承自ViewGroup。PagerAdapter是ViewPager的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用PagerAdapter的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter作为ViewPager的适配器，他们的特点是界面是Fragment。 在support v13和support v4中都提供了FragmentPagerAdapter和FragmentStatePagerAdapter，区别在于：support v13中使用android.app.Fragment，而support v4使用android.support.v4.app.Fragment。一般都使用support v4中的FragmentPagerAdapter和FragmentStatePagerAdapter。 默认，ViewPager会缓存当前页相邻的界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即Fragment对象，且生命周期函数运行到onResume()），可以通过setOffscreenPageLimit(count)设置离线缓存的界面个数。 FragmentPagerAdapter和FragmentStatePagerAdapter需要重写的方法都一样，常见的重写方法如下： public FragmentPagerAdapter(FragmentManager fm): 构造函数，参数为FragmentManager。如果是嵌套Fragment场景，子PagerAdapter的参数传入getChildFragmentManager()。 Fragment getItem(int position): 返回第position位置的Fragment，必须重写。 int getCount(): 返回ViewPager的页数，必须重写。 Object instantiateItem(ViewGroup container, int position): container是ViewPager对象，返回第position位置的Fragment。 void destroyItem(ViewGroup container, int position, Object object): container是ViewPager对象，object是Fragment对象。 getItemPosition(Object object): object是Fragment对象，如果返回POSITION_UNCHANGED，则表示当前Fragment不刷新，如果返回POSITION_NONE，则表示当前Fragment需要调用destroyItem()和instantiateItem()进行销毁和重建。 默认情况下返回POSITION_UNCHANGED。 懒加载懒加载主要用于ViewPager且每页是Fragment的情况，场景为微信主界面，底部有4个tab，当滑到另一个tab时，先显示”正在加载”，过一会才会显示正常界面。 默认情况，ViewPager会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。 这里懒加载的实现思路是：用户不可见的界面，只初始化UI，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。 这里就实现类似微信那种效果，整个UI布局为：底部用PagerBottomTabStrip项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。 ViewPager默认缓存左右相邻界面，为了避免不必要的重新数据加载（重复调用onCreateView()），因为有4个tab，因此将离线缓存的半径设置为3，即setOffscreenPageLimit(3)。 懒加载主要依赖Fragment的setUserVisibleHint(boolean isVisible)方法，当Fragment变为可见时，会调用setUserVisibleHint(true)；当Fragment变为不可见时，会调用setUserVisibleHint(false)，且该方法调用时机： onAttach()之前，调用setUserVisibleHint(false)。 onCreateView()之前，如果该界面为当前页，则调用setUserVisibleHint(true)，否则调用setUserVisibleHint(false)。 界面变为可见时，调用setUserVisibleHint(true)。 界面变为不可见时，调用setUserVisibleHint(false)。 懒加载Fragment的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public abstract class BaseLazyFragment extends Fragment &#123; protected Context mContext; protected boolean isInit;//loadLazyData 之后要设为 true ,防止重复加载 private boolean mIsPrepared; @Override public void onAttach(Context context) &#123; super.onAttach(context); mContext = context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; super.onCreateView(inflater, container, savedInstanceState); if (getArguments() != null) &#123; getFragmentArguments(getArguments()); &#125; return inflater.inflate(getContentView(), container, false); &#125; @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); initView(view, savedInstanceState); &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); mIsPrepared = true; lazyLoad(); &#125; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); if (isVisibleToUser) &#123; lazyLoad(); &#125; &#125; private void lazyLoad() &#123; if (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !isInit) &#123; //异步初始化 loadLazyData(); &#125; &#125; protected abstract void getFragmentArguments(Bundle args); @LayoutRes protected abstract int getContentView(); protected abstract void initView(View view, @Nullable Bundle savedInstanceState); protected abstract void loadLazyData(); public void showToast(String content) &#123; ShowUtils.showToast(content); &#125; /** * 显示是否正在加载中 */ public void showLoading(boolean toggle) &#123; if (toggle) &#123; ShowUtils.showProgressDialog(mContext); &#125; else &#123; ShowUtils.dismissProgressDialog(); &#125; &#125;&#125; 注： 在Fragment中有两个变量控制是否需要做数据加载： mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。 mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为setUserVisibleHint(true)在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。 lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Intent]]></title>
    <url>%2F2017%2FAndroid%2FIntent%2F</url>
    <content type="text"><![CDATA[介绍 Intent 的一些特殊使用（未完待续） 1、&lt;intent-filter&gt;与Action和Category项（动作和附加类别信息）例如: 1234&lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt; 一个Intent对象最多只能包含一个Action属性，通过setAction()来设置属性值； 一个Intent对象可以包含多个Category属性，通过addCategory()来添加Category属性 但是在AndroidManifest.xml中，Activity里的&lt;intent-filter&gt;可以有多个Action属性和Category属性 当Intent被创建时，该Intent默认启动Category属性值为Intent.CATEGORY_DEFAULT属性（常量值为android.intent.category.DEFAULT）的组件。 实际上，Android内部提供了大量标准Action、Catetory常量。（电话、短信、web） 2、&lt;intent-filter&gt;与Data和Type项Data属性通常用于向Action属性提供操作的数据。Data数据接受一个Uri对象。 Type属性用于指定该Data所指定Uri对应的MIME类型（可为任意自定义类型，须符合abc/xyz格式即可） 注： 两属性直接存在相互覆盖的情况（按设置顺序，后者覆盖前者），若要两者同时存在，则使用setDataAndType()方法。 3、Extra属性该属性通常用于多个Activity之间进行数据交换，Intent的Extra属性值应该是一个Bundle对象。 4、Flag属性该属性用于为该Intent添加一些额外的控制旗标。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Handler 详解]]></title>
    <url>%2F2017%2FAndroid%2FHandler%2F</url>
    <content type="text"><![CDATA[Android的UI操作并不是线程安全的。故Android制定了一条简单的规则：只允许UI线程修改Activity里的UI组件。Android不允许在新的线程中访问Activity里面的界面组件。 为了让主线程能“适时”地处理新启动的线程所发送的消息，显然只能通过回调的方式来实现——开发者只要重写Handler类中处理消息的方法，当新启动的线程发送消息时，消息会发送到与之关联的MessageQueue，而Handler会不断从MessageQueue中获取并处理消息——这将导致Handler类中处理消息的方法被回调。 一个线程Thread对应一个Looper，一个Looper对应一个消息队列MessageQueue,一个消息队列MessageQueue中可以包含多条Message消息，一个线程中可以有多个Handler。 Handler类的主要作用有两个： 在新启动的线程中发送消息。 在主线程中获取、处理消息。 关键类Looper：每个线程只有一个Looper，它负责管理MessageQueue，会不断的从MessageQueue中取出消息，并将消息分给对应的Handler处理。 MessageQueue：由Looper负责管理。它采取先进先出的方式来管理Message。 Handler：它能把消息发送给Looper管理的MessageQueue，并负责处理Looper分给它的消息。 如果希望Handler正常工作，必须在当前线程中有一个Looper对象，为了保证当前线程中有Looper对象，可以分如下两种情况处理。 主UI线程中，系统已经初始化了一个Looper对象，因此程序直接创建Handler即可。 如果是自己启动的子线程，就必须自己创建一个Looper对象，并启动它。创建Looper对象调用它的Prepare()方法即可。（Prepare()方法保证每个线程最多只有一个Looper对象） 123456789Public void run()&#123; //创建Looper //prepare()方法中通过ThreadLocal对象实现Looper实例与线程的绑定（源码） Looper .prepare(); //创建Handler子类实例 Handler mHandler = new Handler() &#123;…………&#125;; //启动Looper Looper .loop(); &#125; Looper.prepare() 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 可以看到，首先判断sThreadLocal中是否已经存在Looper了，如果还没有则创建一个新的Looper设置进去。这样也就完全解释了为什么我们要先调用Looper.prepare()方法，才能创建Handler对象。同时也可以看出每个线程中最多只会有一个Looper对象。 Looper.loop() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; Looper.loop()中一直在不断的从消息队列中通过MessageQueue的next方法获取Message，然后通过代码msg.target.dispatchMessage(msg)让该msg所绑定的Handler（Message.target）执行dispatchMessage方法以实现对Message的处理。 Handler三种发送方式sendMessage(Message msg)12345678910111213141516171819202122232425262728293031public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; post(Runnable r)123456789101112131415public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;public final Message obtainMessage()&#123; return Message.obtain(this);&#125; obtainMessage.sendToTarget()12345678public final Message obtainMessage()&#123; return Message.obtain(this);&#125; public void sendToTarget() &#123; target.sendMessage(this);&#125; 三种途径dispatchMessage123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分： 首先尝试让postXXX中传递的Runnable执行， msg.callback 其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理， mCallback 最后才是让Handler自身的handleMessage方法处理Message。 handleMessage() 子线程中进行UI操作另外除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作： Handler.post() View.post() Activity.runOnUiThread() 我们先来看下Handler中的post()方法，代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * * @param r The Runnable that will be executed. * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125;/** * Enqueue a message into the message queue after all pending messages * before (current time + delayMillis). You will receive it in * &#123;@link #handleMessage&#125;, in the thread attached to this handler. * * @return Returns true if the message was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. Note that a * result of true does not mean the message will be processed -- if * the looper is quit before the delivery time of the message * occurs then the message will be dropped. */public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125; 上面调用了sendMessageDelayed()方法去发送一条消息，并且还使用了getPostMessage()方法将Runnable对象转换成了一条消息。 getPostMessage() 方法中将消息的callback字段的值指定为传入的Runnable对象。 这个callback字段看起来有些眼熟，我们回Handler，在dispatchMessage()方法中原来有做一个检查，如果Message的callback等于null才会去调用handleMessage()方法，否则就调用handleCallback()方法。下面是handleCallback()方法中的代码 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 我们可以看到。这里直接调用了一开始传入的Runnable对象的run()方法。因此在子线程中通过Handler的post()方法进行UI操作就可以这么写： 1234567891011121314151617181920212223242526 handler = new Handler(); new Thread(new Runnable() &#123; @Override public void run() &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; //在这里进行UI操作 &#125; &#125;); &#125; &#125;).start();//回见 public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 虽然写法上相差很多，但是原理是完全一样的，我们在Runnable对象的run()方法里更新UI，效果完全等同于在handleMessage()方法中更新UI。因为dispatchMessage()中会先判断 msg.callback（其实就是Runnable）对象是否存在，存在就直接调用run()方法。 然后再来看一下View中的post()方法，代码如下所示： 123456789101112131415161718192021222324/** * &lt;p&gt;Causes the Runnable to be added to the message queue. * The runnable will be run on the user interface thread.&lt;/p&gt; * * @param action The Runnable that will be executed. * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. * * @see #postDelayed * @see #removeCallbacks */public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; 其实也就是调用了Handler中的post()方法。 最后再来看一下Activity中的runOnUiThread()方法，代码如下所示： 1234567891011121314/** * Runs the specified action on the UI thread. If the current thread is the UI * thread, then the action is executed immediately. If the current thread is * not the UI thread, the action is posted to the event queue of the UI thread. * * @param action the action to run on the UI thread */public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。 通过以上所有源码的分析，我们已经发现了，不管是使用哪种方法在子线程中更新UI，其实背后的原理都是相同的，必须都要借助异步消息处理的机制来实现。 总结一下就是 调用Looper.prepare创建Looper和MessageQueue对象 Handler通过调用post将runnable发送给MessageQueue，或者通过调用sendMessage将Message发送给MessageQueue MessageQueue对消息进行一个管理，什么时间哪条消息出栈一是看handler放进来时的意愿，二是看顺序 Looper.loop将消息循环起来，利用Handler去分发消息 消息可以Message自己处理，也可以Handler去处理]]></content>
      <categories>
        <category>Android</category>
        <category>进程线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fragment 详细解析]]></title>
    <url>%2F2017%2FAndroid%2FFragment%2F</url>
    <content type="text"><![CDATA[摘录：Fragment全解析系列（二）：正确的使用姿势 参考博客-天天P图工程师 注：代码来自 com.android.support:support-v4:25.3.1 Fragment核心的类有： Fragment：Fragment的基类，任何创建的Fragment都需要继承该类。 FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl。 FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord。 Nested Fragment（Fragment内部嵌套Fragment的能力）是Android 4.2提出的，support-fragment库可以兼容到1.6。通过getChildFragmentManager()能够获得管理子Fragment的FragmentManager，在子Fragment中可以通过getParentFragment()获得父Fragment。 基本使用利用AS直接生成Fragment 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class BlankFragment extends Fragment &#123; // TODO: Rename parameter arguments, choose names that match // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER private static final String ARG_PARAM1 = "param1"; private static final String ARG_PARAM2 = "param2"; // TODO: Rename and change types of parameters private String mParam1; private String mParam2; private OnFragmentInteractionListener mListener; public BlankFragment() &#123; // Required empty public constructor &#125; /** * Use this factory method to create a new instance of * this fragment using the provided parameters. * * @param param1 Parameter 1. * @param param2 Parameter 2. * @return A new instance of fragment Blank2Fragment. */ // TODO: Rename and change types and number of parameters public static BlankFragment newInstance(String param1, String param2) &#123; Blank2Fragment fragment = new Blank2Fragment(); Bundle args = new Bundle(); args.putString(ARG_PARAM1, param1); args.putString(ARG_PARAM2, param2); fragment.setArguments(args); return fragment; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (getArguments() != null) &#123; mParam1 = getArguments().getString(ARG_PARAM1); mParam2 = getArguments().getString(ARG_PARAM2); &#125; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View root = inflater.inflate(R.layout.demo,container,false); return root; &#125; // TODO: Rename method, update argument and hook method into UI event public void onButtonPressed(Uri uri) &#123; if (mListener != null) &#123; mListener.onFragmentInteraction(uri); &#125; &#125; @Override public void onAttach(Context context) &#123; super.onAttach(context); if (context instanceof OnFragmentInteractionListener) &#123; mListener = (OnFragmentInteractionListener) context; &#125; else &#123; throw new RuntimeException(context.toString() + " must implement OnFragmentInteractionListener"); &#125; &#125; @Override public void onDetach() &#123; super.onDetach(); mListener = null; &#125; /** * This interface must be implemented by activities that contain this * fragment to allow an interaction in this fragment to be communicated * to the activity and potentially other fragments contained in that * activity. * &lt;p&gt; * See the Android Training lesson &lt;a href= * "http://developer.android.com/training/basics/fragments/communicating.html" * &gt;Communicating with Other Fragments&lt;/a&gt; for more information. */ public interface OnFragmentInteractionListener &#123; // TODO: Update argument type and name void onFragmentInteraction(Uri uri); &#125;&#125; 涉及的问题 1、 Fragment需要有一个空方法 每一个Fragment必须有一个空的构造方法，这样当Activity恢复状态时Fragment能够被实例化。强烈建议当我们继承Fragment类时，不要添加带有参数的构造方法，因为当Fragment被重新实例化时，这些构造方法不会被调用。如果需要给Fragment传递参数，可以调用setArguments(Bundle)方法，然后在Fragment中调用getArguments()来获取参数。 如果fragment进入后台，此时横竖屏切换，会让fragment重新创建，fragment没有空的构造就会出运行异常。 2、 Layout.Inflate方法 Fragment有很多可以复写的方法，其中最常用的就是onCreateView()，该方法返回Fragment的UI布局，需要注意的是 inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常:The specified child already has a parent. You must call removeView() on the child&#39;s parent first 3、 传参 如果在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下： It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated. 4、 绑定Activity 我们可以在Fragment的onAttach()中通过getArguments()获得传进来的参数，并在之后使用这些参数。如果要获取Activity对象，不建议调用getActivity()，而是在onAttach()中将Context对象强转为Activity对象。 123456789101112131415Activity mActivity;@Overridepublic void onAttach(Context context) &#123; super.onAttach(context); if (context instanceof OnFragmentInteractionListener) &#123; mListener = (OnFragmentInteractionListener) context; &#125; else &#123; throw new RuntimeException(context.toString() + " must implement OnFragmentInteractionListener"); &#125; if (context instanceof Activity) &#123; mActivity = (Activity) context; &#125;&#125; 添加到Activity123456&lt;FrameLayout android:id="@+id/fragment_container" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/FrameLayout&gt; 12345getSupportFragmentManager() .beginTransaction() .add(R.id.fragment_container, BlankFragment.newInstance("a","b"),"blank") //.addToBackStack("BackStack") .commit(); 将Fragment添加到布局FrameLayout中，指定tag的好处是后续我们可以通过BlankFragment frag = getSupportFragmentManager().findFragmentByTag(&quot;blank&quot;)从FragmentManager中查找Fragment对象。 在一次事务中，可以做多个操作，比如同时做add().remove().replace()。 commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。 addToBackStack(&quot;fname&quot;)是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。 Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。 Fragment有个常见的异常：java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState:- Error in Fragment 该异常出现的原因是：commit()在onSaveInstanceState()后调用。 onSaveInstanceState() 只有在系统即将要自动清理销毁Activity或Fragment前才会调用, 比如 由于重力感应 手机从竖屏变为横屏 手机点击Home键和长按Home键 点击电源键锁屏时 从当前Activity跳到另一个Activity 应用内存不足即将自动销毁时等情况 因为Activity的生命周期在Honeycomb出现后有了些许的差别。在Honeycomb之前，Activity是不可被杀死了直到它们被暂停了，也就是说onSaveInstanceState()在要执行onPause()前就被调用了。而从Honeycomb开始，Activity在它们被停止了就才可以销毁，即只有Activity的onSaveInstanceState()会在onStop()之前调用。这个不同可以用如下表格总结： HoneyComb之前 HoneyCombz之后 Activity在onPause之前会被销毁？ 不会 不会 Activity在onstop之前会被销毁？ 会 不会 onSaveInstanceState确保在哪里调用？ onPause onStop 因此在onStop()之后调用commit()会发生异常 解决方案参考博客 在Activity的生命周期函数里谨慎使用commit，大部分的应用只会在Activity的第一次调用onCreate或者相应用户输入的时候使用commit，这两者情况下都不可能遇到这个问题。但，一旦在其他Activity的生命周期函数，比如onActivityResult(),onStart(),onResume()，就变得有点麻烦了。比如，你不应该在FragmentActivity的onResume()里commit，因为存在一些情况onResume()会在Activity恢复信息前调用（具体查看文档）。如果你的应用程序需要在Activity非onCreate()的生命周期函数里commit，那么就在FragmentActivity的onResumeFragments()或者Activity#onPostResume()。这两个方法都会在Activity从它的销毁状态恢复过来后才会调用，因此可以避免状态丢失。（这里有个例子，是我对StackOverflow问题这个问题的回答，可能可以给你一点关于如何在Activity#onActivityResult()做commit的思路）。 防止在异步操作的回调方法里执行transaction操作。这里包括在AsyncTask#onPostExecute() 和LoaderManager.LoaderCallbacks#onLoadFinished()等方法里的操作。在这些方法里操作commit等操作的问题在于这些方法没法活儿当前Activity的生命周期状态。比如考虑如下顺序的事件：1、一个Activity执行了AsyncTask2、用户按了Home键，触发了onSaveInstanceState()和onStop()方法。3、AsyncTask异步操作完成回调了onPostExecute(),并且不知道Activity已经onStop,导致抛出异常。一般来说，去好的防止在这些异步回调方法里发生异常的方法是不要触发这些方法。Google似乎也很赞同这个观点。根据这篇文章，Android团队也认为在异步回调里做commit操作对于用户体验并不是一种好的体验。如果你的应用程序要求在这些方法里进行commit等操作，并没有合适的方式保证回调在onSaveInstanceState()后触发，你可能只能使用commitAllowingStateLoss()并处理可能随之发生的状态丢失。(可以看这两个问题来理解这个问题链接1和链接2) 把commitAllowingStateLoss()作为没有其他办法才使用的方法，commit和commitAllowingStateLoss方法的差别就在于后者不会抛出在状态丢失的时候抛出异常。通常你最好不要使用这个方法，因为这种情况下可能存在状态丢失。更好的方法，是保证你的应用程序在状态丢失前使用commit，因为这会是更好的用户体验。除非状态丢失的事情无法避免，否则不要使用commitAllowingStateLoss(). Fragment生命周期主要体现在以下表中13个方法里，以下是按照Fragment从开始到销毁的先后执行顺序排序。 onInflate public void onInflate(Activity activity, AttributeSet attrs,BundlesavedInstanceState) 在Activity.onCreate方法之前调用，可以获取除了View之外的资源 onAttach public void onAttach(Activity activity) 当fragment第一次与Activity产生关联时就会调用，以后不再调用 onCreate public void onCreate(Bundle savedInstanceState) 在onAttach执行完后会立刻调用此方法，通常被用于读取保存的状态值，获取或者初始化一些数据，但是该方法不执行，窗口是不会显示的，因此如果获取的数据需要访问网络，最好新开线程。 onCreateView public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) 作用：创建Fragment中显示的view,其中inflater用来装载布局文件，container表示&lt;fragment&gt;标签的父标签对应的ViewGroup对象，savedInstanceState可以获取Fragment保存的状态 onViewCreated public void onViewCreated(View view, Bundle savedInstanceState) 继上面后就会调用此方法，相关view绑定可以在此进行 onActivityCreated public void onActivityCreated(Bundle savedInstanceState) 在Activity.onCreate方法调用后会立刻调用此方法，表示窗口已经初始化完毕，此时可以调用控件了 onStart public void onStart() 开始执行与控件相关的逻辑代码，如按键点击 onResume public void onResume() 这是Fragment从创建到显示的最后一个回调的方法 onPause public void onPause() 当发生界面跳转时，临时暂停，暂停时间是500ms,0.5s后直接进入下面的onStop方法 onStop public void onStop() 当该方法返回时，Fragment将从屏幕上消失 onDestroyView public void onDestroyView() 当fragment状态被保存，或者从回退栈弹出，该方法被调用 onDestroy public void onDestroy() 当Fragment不再被使用时，如按返回键，就会调用此方法 onDetach public void onDetach() Fragment生命周期的最后一个方法，执行完后将不再与Activity关联，将释放所有fragment对象和资源 切换例子：两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。 由 Log 可知 Fragment的onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的。 Fragment的onResume()在Activity的onResume()之后调用。 接下去分两种情况，分别是不加addToBackStack()和加addToBackStack()。 1、当点击F1的按钮，调用replace()替换为F2，且不加addToBackStack()时，日志如下： Fragment2.onAttach-&gt;onCreate-&gt;Fragment1.onPause-&gt;onStop-&gt;onDestroyView-&gt;onDestroy-&gt;onDetach-&gt; Fragment2.onCreateView-&gt;onViewCreated-&gt;onActivityCreated-&gt;onStart-&gt;onResume 可以看到，F1最后调用了onDestroy()和onDetach()。 2、当点击F1的按钮，调用replace()替换为F2，且加addToBackStack()时，日志如下： Fragment2.onAttach-&gt;onCreate-&gt;Fragment1.onPause-&gt;onStop-&gt;onDestroyView Fragment2.onCreateView-&gt;onViewCreated-&gt;onActivityCreated-&gt;onStart-&gt;onResume 可以看到，F1被替换时，最后只调到了onDestroyView()，并没有调用onDestroy()和onDetach()。当用户点返回按钮回退事务时，F1会调onCreateView()-&gt;onStart()-&gt;onResume()，因此在Fragment事务中加不加addToBackStack()会影响Fragment的生命周期。 FragmentTransaction的一些基本方法：下面给出调用这些方法时，Fragment生命周期的变化： add(): onAttach()-&gt;…-&gt;onResume()。 remove(): onPause()-&gt;…-&gt;onDetach()。 replace(): 相当于旧Fragment调用remove()，新Fragment调用add()。 show(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为true。 hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。 detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被FragmentManager管理。 attach(): onCreateView()-&gt;onStart()-&gt;onResume()。 Fragment实现原理和Back Stack我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的。默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment事务加入回退栈，则可以加入addToBackStack(&quot;&quot;)。如果没有加入回退栈，则用户点击返回按钮会直接将Activity出栈；如果加入了回退栈，则用户点击返回按钮会回滚Fragment事务。 12345getSupportFragmentManager() .beginTransaction() .add(R.id.fragment_container, BlankFragment.newInstance("a","b"),"blank") //.addToBackStack("BackStack") .commit(); 查看FragmentManager源码 ，其由三个类组成： 当我们调用beginTransaction时，其由FragmentManagerImpl实现， 1234567891011121314public abstract class FragmentManagerfinal class FragmentManagerState implements Parcelablefinal class FragmentManagerImpl extends FragmentManager implements LayoutInflaterFactory @Override public FragmentTransaction beginTransaction() &#123; return new BackStackRecord(this); &#125; final class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, FragmentManagerImpl.OpGenerator &#123; &#125; 从定义可以看出，BackStackRecord有三重含义： 继承了FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。 实现了BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack()时能回退整个事务。 待了解FragmentManagerImpl.OpGenerator，感觉是状态处理 BackStackRecord类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是Op类，表示其中某个操作，定义如下： 12345678static final class Op &#123; int cmd;//操作的命令（add，remove。replace。。。） Fragment fragment;//操作的Fragment对象 int enterAnim; int exitAnim; int popEnterAnim; int popExitAnim;&#125; 下面我们来看add操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overridepublic FragmentTransaction add(int containerViewId, Fragment fragment) &#123; doAddOp(containerViewId, fragment, null, OP_ADD); return this;&#125;private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123; final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) &#123; throw new IllegalStateException("Fragment " + fragmentClass.getCanonicalName() + " must be a public static class to be properly recreated from" + " instance state."); &#125; fragment.mFragmentManager = mManager; if (tag != null) &#123; if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) &#123; throw new IllegalStateException("Can't change tag of fragment " + fragment + ": was " + fragment.mTag + " now " + tag); &#125; fragment.mTag = tag; &#125; if (containerViewId != 0) &#123; if (containerViewId == View.NO_ID) &#123; throw new IllegalArgumentException("Can't add fragment " + fragment + " with tag " + tag + " to container view with no id"); &#125; if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) &#123; throw new IllegalStateException("Can't change container ID of fragment " + fragment + ": was " + fragment.mFragmentId + " now " + containerViewId); &#125; fragment.mContainerId = fragment.mFragmentId = containerViewId; &#125; Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; addOp(op);&#125;void addOp(Op op) &#123; mOps.add(op);//add()是将创建好的Op对象加入链表 op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim;&#125; 接着看commit操作 1234567891011121314151617181920212223@Overridepublic int commit() &#123; return commitInternal(false);&#125;int commitInternal(boolean allowStateLoss) &#123; if (mCommitted) throw new IllegalStateException("commit already called"); if (FragmentManagerImpl.DEBUG) &#123; Log.v(TAG, "Commit: " + this); LogWriter logw = new LogWriter(TAG); PrintWriter pw = new PrintWriter(logw); dump(" ", null, pw, null); pw.close(); &#125; mCommitted = true; if (mAddToBackStack) &#123; mIndex = mManager.allocBackStackIndex(this); &#125; else &#123; mIndex = -1; &#125; mManager.enqueueAction(this, allowStateLoss); return mIndex;&#125; 如果mAddToBackStack为true，则调用allocBackStackIndex(this)将事务添加进回退栈，FragmentManager类的变量ArrayList&lt;BackStackRecord&gt; mBackStackIndices;就是回退栈。实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public int allocBackStackIndex(BackStackRecord bse) &#123; synchronized (this) &#123; if (mAvailBackStackIndices == null || mAvailBackStackIndices.size() &lt;= 0) &#123; if (mBackStackIndices == null) &#123; mBackStackIndices = new ArrayList&lt;BackStackRecord&gt;(); &#125; int index = mBackStackIndices.size(); if (DEBUG) Log.v(TAG, "Setting back stack index " + index + " to " + bse); mBackStackIndices.add(bse); return index; &#125; else &#123; int index = mAvailBackStackIndices.remove(mAvailBackStackIndices.size()-1); if (DEBUG) Log.v(TAG, "Adding back stack index " + index + " with " + bse); mBackStackIndices.set(index, bse); return index; &#125; &#125;&#125;/** * Adds an action to the queue of pending actions. * * @param action the action to add * @param allowStateLoss whether to allow loss of state information * @throws IllegalStateException if the activity has been destroyed */public void enqueueAction(OpGenerator action, boolean allowStateLoss) &#123; if (!allowStateLoss) &#123; checkStateLoss(); &#125; synchronized (this) &#123; if (mDestroyed || mHost == null) &#123; throw new IllegalStateException("Activity has been destroyed"); &#125; if (mPendingActions == null) &#123; mPendingActions = new ArrayList&lt;&gt;(); &#125; mPendingActions.add(action); scheduleCommit(); &#125;&#125;/** * Schedules the execution when one hasn't been scheduled already. This should happen * the first time &#123;@link #enqueueAction(OpGenerator, boolean)&#125; is called or when * a postponed transaction has been started with * &#123;@link Fragment#startPostponedEnterTransition()&#125; */private void scheduleCommit() &#123; synchronized (this) &#123; boolean postponeReady = mPostponedTransactions != null &amp;&amp; !mPostponedTransactions.isEmpty(); boolean pendingReady = mPendingActions != null &amp;&amp; mPendingActions.size() == 1; if (postponeReady || pendingReady) &#123; mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); &#125; &#125;&#125; mPendingActions就是前面说的待执行队列，mHost.getHandler()就是主线程的Handler，因此Runnable是在主线程执行的，mExecCommit的内部就是调用了execPendingActions()，即把mPendingActions中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用BackStackRecord的run()方法，run()方法就是执行Fragment的生命周期函数，还有将视图添加进container中。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask]]></title>
    <url>%2F2017%2FAndroid%2FAsynctask%2F</url>
    <content type="text"><![CDATA[AsyncTask 的介绍与使用 AsyncTask&lt;&gt;是一个抽象类，通常用于被继承。适用于简单的异步处理，不需要借助线程和Handler即可实现。 它定义了如下三种泛型类型。 Params：启动任务执行的输入参数的类型 Progress：后台任务完成的进度值的类型 Result：后台执行任务完成后返回结果的类型 使用方式 创建AsyncTask的子类，并为三个泛型参数指定类型。如果某个泛型参数不需要指定类型，可将它指定为Void 根据需要可使用如下方法 doInBackground(Params…)：重写该方法就是后台线程将要完成的任务。该方法可以调用publiceProgress ( Progress…values)方法更新任务的执行进度。 onProgressUpdate (Progress…values)：在doInBackground()方法中调用publicProgress()方法更新任务的执行进度后，将会触发该方法。 onPreExecute()：该方法将在执行后台耗时操作前被调用。通常该方法用于完成一些初始化的准备工作，比如在界面上显示进度条。 onPostExecute( Result result)：当doInBackground()完成后，系统会自动调用该方法，并将doInBackground()的返回值传给该方法 调用AsyncTask子类的实例的execute(Params…params)开始执行耗时任务 注： 必须在UI线程中创建AsyncTask的实例 必须在UI线程中调用AsyncTask的execute()方法 AsyncTask的onPreExecute()、onPostExecute(Result result)、doInBackground(Params…params),onProgressUpdate(Progress…values)方法，不应该由程序员代码调用，要由系统调用 每个AsyncTask只能被执行一次，多次调用将会引发异常 AsyncTask中的三个泛型参数的类型与四个方法中参数的关系第一个参数类型为Params的泛型： AsyncTask子类的实例调用execute()方法中传入参数类型，参数为该类型的可变长数组doInBackground()方法的参数类型，参数为该类型的可变长数组 第二个参数类型为Progress的泛型: 在doInBackground方法中手动调用publishProgress方法中传入参数的类型，参数为该类型的可变长数组 onProgressUpdate()方法中的参数类型，参数为该类型的可变长数组 第三个参数类型为Result的泛型: doInBackground()方法的返回值的类型 onPostExecute方法的参数的类型]]></content>
      <categories>
        <category>Android</category>
        <category>进程线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XML Drawable]]></title>
    <url>%2F2017%2FAndroid%2FXML%20Drawable%2F</url>
    <content type="text"><![CDATA[资源文件 XML 的详细介绍参考链接 StateListDrawable资源 12345678&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- 指定获得焦点时的颜色 --&gt; &lt;item android:state_focused="true" android:color="#f44"/&gt; &lt;!-- 指定失去焦点时的颜色 --&gt; &lt;item android:state_focused="false" android:color="#eee"/&gt;&lt;/selector&gt; LayerDrawable资源 12345678&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!-- 定义轨道的背景 --&gt; &lt;item android:id="@android:id/background" android:drawable="@drawable/grow" /&gt; &lt;!-- 定义轨道上已完成部分的外观--&gt; &lt;item android:id="@android:id/progress" android:drawable="@drawable/ok" /&gt;&lt;/layer-list&gt; ClipDrawable资源 123456&lt;clip xmlns:android="http://schemas.android.com/apk/res/android"&gt; android:drawable="@drawable/shuangta"//截取的源Drawable对象 android:clipOrientation="horizontal"//指定截取方向 android:gravity="center"&gt;//指定截取的对齐方式&lt;/clip&gt;可通过setLevel（int level）方法控制截取的图片部分，0&lt;= level &lt;= 10000，零到整张图。可实现幻灯片特效 样式资源和主题资源 1234567891011121314151617181920&lt;resources&gt; &lt;!--定义一个样式，指定字体大小、字体颜色--&gt; &lt;style name="style1"&gt; &lt;item name="android:textSize"&gt;20sp&lt;/item&gt; &lt;item name="android:textColor"&gt;#00d&lt;/item&gt; &lt;/style&gt; &lt;!--定义一个样式，继承前一个颜色--&gt; &lt;style name="style2" parent="@style/style1"&gt; &lt;item name="android:background"&gt;#ee6&lt;/item&gt; &lt;item name="android:padding"&gt;8dp&lt;/item&gt; &lt;!--覆盖父样式中指定的属性--&gt; &lt;item name="android:textColor"&gt;#000&lt;/item&gt; &lt;/style&gt; &lt;style name="CrazyTheme"&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowFullscreen"&gt;true&lt;/item&gt; &lt;item name="android:windowFrame"&gt;@drawable/window_border&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@drawable/star&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>UI系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统组件]]></title>
    <url>%2F2017%2FAndroid%2F%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android UI组件的一些低频高端的使用 TextViewspannable spannableStringBuilder.setSpan(What,Start,End,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); What：//设置字体大小（相对值,单位：像素 参数表示为默认字体大小的多少倍 new RelativeSizeSpan(0.5f) new RelativeSizeSpan(2.0f) //设置字体前景色new ForegroundColorSpan(Color.MAGENTA) //设置字体背景色new BackgroundColorSpan(Color.CYAN) //设置字体样式new StyleSpan(android.graphics.Typeface.NORMAL)正常 new StyleSpan(android.graphics.Typeface.BOLD)粗体 new StyleSpan(android.graphics.Typeface.ITALIC)斜体 粗斜体new StyleSpan(android.graphics.Typeface.BOLD_ITALIC) //设置下划线new UnderlineSpan() //设置删除线new StrikethroughSpan() //设置上下标new SubscriptSpan() 下标 new SuperscriptSpan() 上标 //超级链接（需要添加setMovementMethod方法附加响应） mTextView.setMovementMethod(LinkMovementMethod.getInstance()); new URLSpan(“tel:4155551212””mailto:webmaster@google.com“”http://www.baidu.com“”sms:4155551212””mms:4155551212” “geo:38.899533,-77.036476”) 电话邮件网址短信彩信地图 空格占位法参考链接 HTML特殊字符编码对照表 HTML特殊字符编码对照表 说明 实体名称 实体编号 半方大的空白 &#8194; 全方大的空白 &#8195; 不断行的空白格 &#160; &lt; 小于 &lt; &#60; &gt; 大于 &gt; &#62; &amp; &amp;符号 &amp; &#38; “ 双引号 “ &#34; © 版权 © &#169; ® 已注册商标 ® &#174; ™ 商标（美国） ™ &#8482; × 乘号 × &#215; ÷ 除号 ÷ &#247; 使用普通的英文半角空格&amp;#160;解决问题，实测并非一定对齐 使用HTML编码 &#8194; &#8195; 来处理 1234android:text="联&amp;#8194;系&amp;#8194;人：：" /&gt; android:text="电&amp;#8195;&amp;#8195;话：：" /&gt; android:text="详细信息：" /&gt;android:text="企业Q&amp;#8197;&amp;#8197;Q" /&gt; ListViewaddheadView 需要在setAdapter 之前设置]]></content>
      <categories>
        <category>Android</category>
        <category>UI系列</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个爬虫]]></title>
    <url>%2F2017%2FPython%2F%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[最近开始学习 python，暂且作为记录先把代码放上主要实现的功能是对 hosts 文件的更新获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/local/bin/python3import requestsfrom bs4 import BeautifulSoupimport bs4import reimport zipfiledef getHtml(url): try: r = requests.get(url) r.raise_for_status r.encoding = r.apparent_encoding return r.text except Exception as e: raise edef getHtmlTitle(html): soup = BeautifulSoup(html,"html.parser") return soup.titledef getPwd(html): soup = BeautifulSoup(html,"html.parser") links = soup.find_all('span') pwd = "" for link in links: if "百度网盘" in link.get_text() : print(link.get_text()) pwd = link.get_text() list = pwd.split("：") pwd = list[2] break return pwddef getTitleDate(title): num = re.search( r'2017-\d\d-\d\d',title.string) date = num.group() print("最新更新日期为："+date) return re.sub(r'\D', "", date)def getFileName(downloadHtml): soup = BeautifulSoup(downloadHtml,"html.parser") links = soup.find_all('a') # for link in links: # print (link.name,link['href'],link.get_text() ) # print(links[2]['href']) return links[2]['href']def downLoad(downloadUrl,date): print(downloadUrl) r = requests.get(downloadUrl) with open("hosts"+date+".zip", "wb") as code: code.write(r.content)def extract(name,pwd): f = zipfile.ZipFile(name, 'r') for file in f.namelist(): f.extract(file,".",str.encode(s))#b"google" ，密码需为byte格式def main(): url = "https://laod.cn/hosts/2017-google-hosts.html" serverUrl = "https://iiio.io/download/" html = getHtml(url) title = getHtmlTitle(html) date = getTitleDate(title) serverHtml = getHtml(serverUrl + date) # print(serverUrl + date) fileName = getFileName(serverHtml) downloadUrl = serverUrl+date+'/'+fileName downLoad(downloadUrl,date) print("下载完成") pwd = getPwd(html) extract("hosts"+date+".zip",pwd) print("任务完成") main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>hosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客修改心得]]></title>
    <url>%2F2017%2FNext%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[其实就是记录下自己修改博客相关内容和 Next 主题的一些笔记 网站标题设置 /source/css/_schemes/Muse/_logo.styl.site-title 网站副标题设置 /source/css/_common/components/header/site-meta.styl.site-subtitle 网站 banner 设置 /layout/_partials/header.swig/source/css/_schemes/Muse/_logo.styl 背景图 Url 设置关于 banner，我是在 header.swig 中重新布局的，仅针对 Muse 主题。其中的设计来自「夏末」，也就是 Next 主题作者的 banner。 如果有人知道那个背景跟随鼠标移动式怎么实现的，还希望能得到分享已在下面的 hexo-Next 主题优化中得到解決 网站 sidebar 设置 /layout/_macro/sidebar.swig //插入网易云音乐，放弃该操作，改为在个人页显示/source/css/_common/components/sidebar/sidebar.styl 參考 XuewenDing 写的 hexo-Next 主题优化 link: hexo-Next主题优化 首先找到 \themes\next\layout_layout.swig，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。 默认灰色线条 12&lt;script type=&quot;text/javascript&quot;src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt; 浅蓝色线条 12&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt; 然后在 themes\source\js\src\下新建文件 particle.js 写上以下代码: 1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=&quot;rgba(&quot;+m.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement(&quot;canvas&quot;),m=t(),d=&quot;c_n&quot;+m.l,l=u.getContext(&quot;2d&quot;),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+m.z+&quot;;opacity:&quot;+m.o,e(&quot;body&quot;)[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;();]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>hexo-Next主题</tag>
      </tags>
  </entry>
</search>
