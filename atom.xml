<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen_Nuo&#39;s Blog</title>
  
  <subtitle>Dream It Possible</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chennuo.online/"/>
  <updated>2019-02-25T01:53:10.000Z</updated>
  <id>http://chennuo.online/</id>
  
  <author>
    <name>晨诺secret</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java序列化问题</title>
    <link href="http://chennuo.online/2019/Java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>http://chennuo.online/2019/Java/Java序列化问题/</id>
    <published>2019-02-25T01:53:10.000Z</published>
    <updated>2019-02-25T01:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>序列化 ID 的问题</li><li>静态变量序列化</li><li>父类的序列化与 Transient 关键字</li><li>对敏感字段加密</li><li>序列化存储规则</li></ul><a id="more"></a><h3 id="序列化-ID-的问题"><a href="#序列化-ID-的问题" class="headerlink" title="序列化 ID 的问题"></a>序列化 ID 的问题</h3><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）</p><p>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><p><strong>典型例子</strong></p><p>Client 端通过 Façade Object 才可以与业务逻辑对象进行交互。而客户端的 Façade Object 不能直接由 Client 生成，而是需要 Server 端生成，然后序列化后通过网络将二进制对象数据传给 Client，Client 负责反序列化得到 Façade 对象。该模式可以使得 Client 端程序的使用需要服务器端的许可，同时 Client 端和服务器端的 Façade Object 类需要保持一致。当服务器端想要进行版本更新时，只要将服务器端的 Façade Object 类的序列化 ID 再次生成，当 Client 端反序列化 Façade Object 就会失败，也就是强制 Client 端从服务器端获取最新程序。</p><h3 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h3><p><strong>序列化时，并不保存静态变量</strong>，这其实比较容易理解，序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。</p><h3 id="父类的序列化与-Transient-关键字"><a href="#父类的序列化与-Transient-关键字" class="headerlink" title="父类的序列化与 Transient 关键字"></a>父类的序列化与 Transient 关键字</h3><p>要想将父类对象也序列化，就需要让父类也实现Serializable 接口。如果父类不实现的话的，就需要有默认的无参的构造函数。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p><p>Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。</p><p><strong>典型例子</strong></p><p>我们熟悉使用 Transient 关键字可以使得字段不被序列化，那么还有别的方法吗？根据父类对象序列化的规则，我们可以将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化，形成类图如图 2 所示。</p><h3 id="对敏感字段加密"><a href="#对敏感字段加密" class="headerlink" title="对敏感字段加密"></a>对敏感字段加密</h3><p>在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。基于这个原理，可以在实际应用中得到使用，用于敏感字段的加密工作。</p><h3 id="序列化存储规则"><a href="#序列化存储规则" class="headerlink" title="序列化存储规则"></a>序列化存储规则</h3><p>对同一对象两次写入文件，打印出写入一次对象后的存储大小和写入两次后的存储大小，然后从文件中反序列化出两个对象，比较这两个对象是否为同一对象。一般的思维是，两次写入对象，文件大小会变为两倍的大小，反序列化时，由于从文件读取，生成了两个对象，判断相等时应该是输入 false 才对，但是最后结果输出如下</p><pre><code>31  36 true</code></pre><p>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，上面增加的 5 字节的存储空间就是新增引用和一些控制信息的空间。反序列化时，恢复引用关系，使得清单 3 中的 t1 和 t2 指向唯一的对象，二者相等，输出 true。该存储规则极大的节省了存储空间。</p><p>参考资料：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-serial/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;序列化 ID 的问题&lt;/li&gt;
&lt;li&gt;静态变量序列化&lt;/li&gt;
&lt;li&gt;父类的序列化与 Transient 关键字&lt;/li&gt;
&lt;li&gt;对敏感字段加密&lt;/li&gt;
&lt;li&gt;序列化存储规则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://chennuo.online/categories/Java/"/>
    
    
      <category term="Java序列化" scheme="http://chennuo.online/tags/Java%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="Transient关键字" scheme="http://chennuo.online/tags/Transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>设备分辨率与Bitmap</title>
    <link href="http://chennuo.online/2019/Android/%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8EBitmap/"/>
    <id>http://chennuo.online/2019/Android/设备分辨率与Bitmap/</id>
    <published>2019-02-22T02:28:13.000Z</published>
    <updated>2019-02-22T02:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设备分辨率"><a href="#设备分辨率" class="headerlink" title="设备分辨率"></a>设备分辨率</h3><table><thead><tr><th style="text-align:center">density</th><th style="text-align:center">0.75</th><th style="text-align:center">1</th><th style="text-align:center">1.5</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">3.5</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">densityDpi</td><td style="text-align:center">120</td><td style="text-align:center">160</td><td style="text-align:center">240</td><td style="text-align:center">320</td><td style="text-align:center">480</td><td style="text-align:center">560</td><td style="text-align:center">640</td></tr><tr><td style="text-align:center">DpiFolder</td><td style="text-align:center">ldpi</td><td style="text-align:center">mdpi</td><td style="text-align:center">hdpi</td><td style="text-align:center">xhdpi</td><td style="text-align:center">xxhdpi</td><td style="text-align:center">xxxhdpi</td><td style="text-align:center">xxxxhdpi</td></tr></tbody></table><table><thead><tr><th style="text-align:center">Dpi范围</th><th style="text-align:center">密度</th></tr></thead><tbody><tr><td style="text-align:center">0dpi ~ 120dpi</td><td style="text-align:center">ldpi</td></tr><tr><td style="text-align:center">120dpi ~ 160dpi</td><td style="text-align:center">mdpi</td></tr><tr><td style="text-align:center">160dpi ~ 240dpi</td><td style="text-align:center">hdpi</td></tr><tr><td style="text-align:center">240dpi ~ 320dpi</td><td style="text-align:center">xhdpi</td></tr><tr><td style="text-align:center">320dpi ~ 480dpi</td><td style="text-align:center">xxhdpi</td></tr><tr><td style="text-align:center">480dpi ~ 640dpi</td><td style="text-align:center">xxxhdp</td></tr></tbody></table><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><blockquote><p>Bitmap内存占用 ≈ 像素数据总大小 = 图片宽 × 图片高× (设备分辨率/资源目录分辨率)^2 × 每个像素的字节大小</p></blockquote><a id="more"></a><h3 id="单个像素的字节大小"><a href="#单个像素的字节大小" class="headerlink" title="单个像素的字节大小"></a>单个像素的字节大小</h3><table><thead><tr><th style="text-align:center">Config</th><th style="text-align:center">占用字节大小（byte）</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALPHA_8 (1)</td><td style="text-align:center">1</td><td style="text-align:center">单透明通道</td></tr><tr><td style="text-align:center">RGB_565 (3)</td><td style="text-align:center">2</td><td style="text-align:center">简易RGB色调</td></tr><tr><td style="text-align:center">ARGB_4444 (4)</td><td style="text-align:center">4</td><td style="text-align:center">已废弃</td></tr><tr><td style="text-align:center">ARGB_8888 (5)</td><td style="text-align:center">4</td><td style="text-align:center">24位真彩色</td></tr><tr><td style="text-align:center">RGBA_F16 (6)</td><td style="text-align:center">8</td><td style="text-align:center">Android 8.0 新增（更丰富的色彩表现HDR）</td></tr><tr><td style="text-align:center">HARDWARE (7)</td><td style="text-align:center">Special</td><td style="text-align:center">Android 8.0 新增 （Bitmap直接存储在graphic memory）注1</td></tr></tbody></table><h3 id="不同Android版本时的Bitmap内存模型"><a href="#不同Android版本时的Bitmap内存模型" class="headerlink" title="不同Android版本时的Bitmap内存模型"></a>不同Android版本时的Bitmap内存模型</h3><table><thead><tr><th style="text-align:center">API级别</th><th style="text-align:center">API 10 -</th><th style="text-align:center">API 11 ~ API 25</th><th style="text-align:center">API 26 +</th></tr></thead><tbody><tr><td style="text-align:center">Bitmap对象存放</td><td style="text-align:center">Java heap</td><td style="text-align:center">Java heap</td><td style="text-align:center">Java heap</td></tr><tr><td style="text-align:center">像素(pixel data)数据存放</td><td style="text-align:center">native heap</td><td style="text-align:center">Java heap</td><td style="text-align:center">native heap</td></tr></tbody></table><blockquote><p>如果没有在AndroidManifest中启用largeheap，那么Java 堆内存达到192M的时候就会崩溃，对于现在动辄4G的手机而言，存在严重的资源浪费，ios的一个APP几乎能用近所有的可用内存（除去系统开支），8.0之后，Android也向这个方向靠拢，最好的下手对象就是Bitmap，因为它是耗内存大户。图片内存被转移到native之后，一个APP的图片处理不仅能使用系统绝大多数内存，还能降低Java层内存使用，减少OOM风险。不过，内存无限增长的情况下，也会导致APP崩溃，但是这种崩溃已经不是OOM崩溃了，Java虚拟机也不会捕获，按道理说，应该属于linux的OOM了。</p></blockquote><h4 id="8-0之后的Bitmap内存回收机制"><a href="#8-0之后的Bitmap内存回收机制" class="headerlink" title="8.0之后的Bitmap内存回收机制"></a>8.0之后的Bitmap内存回收机制</h4><p>NativeAllocationRegistry是Android 8.0引入的一种辅助自动回收native内存的一种机制，当Java对象因为GC被回收后，NativeAllocationRegistry可以辅助回收Java对象所申请的native内存</p><p>参考资料：<br><a href="https://www.jianshu.com/p/3f6f6e4f1c88" target="_blank" rel="noopener">https://www.jianshu.com/p/3f6f6e4f1c88</a><br><a href="https://www.jianshu.com/p/d5714e8987f3" target="_blank" rel="noopener">https://www.jianshu.com/p/d5714e8987f3</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/50727753" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/50727753</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;设备分辨率&quot;&gt;&lt;a href=&quot;#设备分辨率&quot; class=&quot;headerlink&quot; title=&quot;设备分辨率&quot;&gt;&lt;/a&gt;设备分辨率&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;density&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0.75&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1.5&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;2&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3.5&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;densityDpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;120&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;160&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;240&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;320&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;480&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;560&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;640&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;DpiFolder&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ldpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mdpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;hdpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xhdpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xxhdpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xxxhdpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xxxxhdpi&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Dpi范围&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;密度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0dpi ~ 120dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ldpi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;120dpi ~ 160dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mdpi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;160dpi ~ 240dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;hdpi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;240dpi ~ 320dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xhdpi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;320dpi ~ 480dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xxhdpi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;480dpi ~ 640dpi&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;xxxhdp&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;内存占用&quot;&gt;&lt;a href=&quot;#内存占用&quot; class=&quot;headerlink&quot; title=&quot;内存占用&quot;&gt;&lt;/a&gt;内存占用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Bitmap内存占用 ≈ 像素数据总大小 = 图片宽 × 图片高× (设备分辨率/资源目录分辨率)^2 × 每个像素的字节大小&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
      <category term="Bitmap" scheme="http://chennuo.online/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver</title>
    <link href="http://chennuo.online/2019/Android/BroadcastReceiver/"/>
    <id>http://chennuo.online/2019/Android/BroadcastReceiver/</id>
    <published>2019-02-21T03:35:56.000Z</published>
    <updated>2019-02-21T03:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>广播被分为两种不同的类型：“普通广播（Normal broadcasts）”和“有序广播（Ordered broadcasts）”。</p><p>普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播；</p><p>然而有序广播是按照接收者声明的优先级别（声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000。也可以调用IntentFilter对象的setPriority()进行设置），被接收者依次接收广播。</p><a id="more"></a><h3 id="静态注册和动态注册区别"><a href="#静态注册和动态注册区别" class="headerlink" title="静态注册和动态注册区别"></a>静态注册和动态注册区别</h3><p><strong>8.0 后，Android 推荐使用动态广播注册，大部分静态广播都已失效。</strong></p><p>动态注册广播不是常驻型广播，也就是说广播跟随activity的生命周期。注意: 在activity结束前，移除广播接收器。 </p><p>静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。  </p><p>当广播为有序广播时：</p><ol><li>优先级高的先接收</li><li>同优先级的广播接收器，动态优先于静态</li><li>同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。</li></ol><p>当广播为普通广播时：</p><ol><li>无视优先级，动态广播接收器优先于静态广播接收器</li><li>同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。</li></ol><p><strong>小结：</strong><br>在Android 中如果要发送一个广播必须使用sendBroadCast 向系统发送对其感兴趣的广播接收器中。<br>使用广播必须要有一个intent 对象必设置其action动作对象<br>使用广播必须在配置文件中显式的指明该广播对象<br>每次接收广播都会重新生成一个接收广播的对象<br>在BroadCastReceiver中尽量不要处理太多逻辑问题，建议复杂的逻辑交给Activity 或者 Service 去处理<br>如果在AndroidManifest.xml中注册，当应用程序关闭的时候，也会接收到广播。在应用程序中注册就不产生这种情况了。</p><p>参考资料：<br><a href="https://www.jianshu.com/p/51aaa65d5d25" target="_blank" rel="noopener">https://www.jianshu.com/p/51aaa65d5d25</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广播被分为两种不同的类型：“普通广播（Normal broadcasts）”和“有序广播（Ordered broadcasts）”。&lt;/p&gt;
&lt;p&gt;普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播；&lt;/p&gt;
&lt;p&gt;然而有序广播是按照接收者声明的优先级别（声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000。也可以调用IntentFilter对象的setPriority()进行设置），被接收者依次接收广播。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="四大组件" scheme="http://chennuo.online/categories/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 开发常用命令</title>
    <link href="http://chennuo.online/2018/Android/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://chennuo.online/2018/Android/Android开发常用命令/</id>
    <published>2018-08-08T05:46:09.000Z</published>
    <updated>2018-08-08T05:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-开发常用命令整理"><a href="#Android-开发常用命令整理" class="headerlink" title="Android 开发常用命令整理"></a>Android 开发常用命令整理</h1><p>参考</p><ul><li>《Android 应用安全防护和逆向分析》</li></ul><a id="more"></a><h3 id="adb-shell-命令"><a href="#adb-shell-命令" class="headerlink" title="adb shell 命令"></a>adb shell 命令</h3><blockquote><p>adb shell getprop</p></blockquote><p>查看系统属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vivo： getprop ro.build.version.opporom       获取系统版本号</span><br><span class="line">miui： getprop ro.miui.ui.version.name</span><br></pre></td></tr></table></figure><blockquote><p>adb shell dumpsys activity top</p></blockquote><p>查看当前应用的 activity 信息</p><blockquote><p>adb shell dumpsys package [package]</p></blockquote><p>查看指定包名应用的详细信息（相当于应用的 AndroidManifest.xml）</p><blockquote><p>adb shell dumpsys meminfo [pname/id]</p></blockquote><p>查看指定进程名或者进程 id 的内存信息</p><blockquote><p>adb shell dumpsys dbinfo [package]</p></blockquote><p>可以查看指定包名应用的数据库存储信息（包括存储的 SQL 语句）</p><blockquote><p>adb shell screencap -p [路径]</p></blockquote><p>截屏到指定路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/temp.png</span><br><span class="line">adb pull /sdcard/temp.png D:\</span><br><span class="line">start D:\temp.png</span><br></pre></td></tr></table></figure><blockquote><p>adb forward [(远程端) 协议：端口号] [(设备端) 协议：端口号]</p></blockquote><p>设备的端口转发，该命令在 IDA 调试中非常有用</p><pre><code>adb forward tcp:8700 jdwp:1786</code></pre><blockquote><p>adb jdwp</p></blockquote><p>查看设备中可以被调试的应用的进程号</p><h3 id="adb-shell-中的命令"><a href="#adb-shell-中的命令" class="headerlink" title="adb shell 中的命令"></a>adb shell 中的命令</h3><blockquote><p>run-as [package name]</p></blockquote><p>在非 root 设备中查看指定 debug 模式的包名应用沙盒数据</p><blockquote><p>ps<br>ps | grep 过滤内容<br>ps -t [pid] 查看 pid 对应的进程信息</p></blockquote><blockquote><p>pm clear [package name]</p></blockquote><p>清楚指定包名应用的数据</p><blockquote><p>am start</p></blockquote><p>启动一个应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am start -n [package]/[package].[activity]</span><br></pre></td></tr></table></figure><p>注意：可以用 debug 方式启动应用 ( am start -D -n … ）。特别在反编译调试应用的时候，可能需要 debug 方式启动应用。</p><blockquote><p>am startservice</p></blockquote><p>启动一个服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am startservice -n [package]/[package].[service]</span><br></pre></td></tr></table></figure><blockquote><p>am broadcast</p></blockquote><p>发送一个广播</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">am broadcast -a [broadcast]</span><br></pre></td></tr></table></figure><blockquote><p>netcfg</p></blockquote><p>查看设备 ip 地址</p><blockquote><p>netstat</p></blockquote><p>查看设备的端口号信息</p><blockquote><p>app_process</p></blockquote><p>运行 java 代码</p><p>这个命令主要用于 Android 中一些特殊的开发场景中，想启动一个 jar 包，不过这个 jar 包有要求：需要 dx 命令把 dex 文件转化成 jar 包功能，实际上它不是一个正常的 jar 包了，而是一个包含了 class.dex 文件的压缩文件了。</p><blockquote><p>dalvikvm</p></blockquote><p>运行一个 dex 文件</p><p>有时候为了测试一个 dex 文件功能可以用到这个命令，与上面的命令有很大的相似之处，只是运行的文件不一样。</p><blockquote><p>top</p></blockquote><p>查看当前应用的 CPU 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tap [-n/-m/-d/-s/-t]</span><br><span class="line">-m  最多显示多少个进程</span><br><span class="line">-n  刷新次数</span><br><span class="line">-d  刷新间隔时间</span><br><span class="line">-s  按哪列排序</span><br><span class="line">-t  显示线程信息而不是进程</span><br><span class="line"></span><br><span class="line">top -d 1 -m 10</span><br></pre></td></tr></table></figure><p>这个命令在分析应用性能的时候非常有用，可以用 grep 过滤想要分析的应用信息，查看它的当前 CPU 使用率。</p><blockquote><p>getprop</p></blockquote><p>查看系统属性值</p><p>getprop ro.debuggable</p><p>root 设备之后，可以通过修改这些系统属性。比如 debug 开关，让所有应用都处于可调试状态。</p><h3 id="操作-apk-命令"><a href="#操作-apk-命令" class="headerlink" title="操作 apk 命令"></a>操作 apk 命令</h3><blockquote><p>aapt</p></blockquote><p>查看 apk 中的信息以及编辑 apk 程序包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aapt dump xmltree [.apk] [.xml]</span><br></pre></td></tr></table></figure><blockquote><p>dexdump [dex 文件路径]</p></blockquote><p>查看一个 dex 文件的详细信息</p><h3 id="进程命令"><a href="#进程命令" class="headerlink" title="进程命令"></a>进程命令</h3><blockquote><p>cat /proc/[pid]/maps</p></blockquote><p>查看当前进程的内存映射信息，比如加载了哪些 so 文件， dex 文件等。</p><blockquote><p>cat /proc/[pid]/status</p></blockquote><p>查看当前进程的状态信息，比如 TracerPid 。</p><h3 id="adb-获取手机-apk"><a href="#adb-获取手机-apk" class="headerlink" title="adb 获取手机 apk"></a>adb 获取手机 apk</h3><ul><li><p>列出手机包名：adb shell pm list package</p></li><li><p>获取 apk 安装路径：adb shell pm path ‘package name’<br>adb shell pm path com.google.android.youtube<br>package:/data/app/com.google.android.youtube-1/base.apk</p></li><li><p>使用 pull 命令获取apk：adb pull ‘package-path’ ‘new.apk’<br>adb pull /data/app/com.google.android.youtube-1/base.apk youtube.apk<br>/data/app/com.google.android.youtube-1/base.apk: 1 file pulled. 2.7 MB/s (21504340 bytes in 7.724s)</p></li><li><p>总结： adb shell pm 命令获取安装包路径， adb pull 命令拿到安装包。</p></li></ul><h3 id="adb-wifi-调试"><a href="#adb-wifi-调试" class="headerlink" title="adb wifi 调试"></a>adb wifi 调试</h3><ul><li><p>adb tcpip [端口号（随便写个大点的比如：5555）]</p></li><li><p>adb connect [手机 ip]</p></li><li><p>adb usb （换回usb模式 ）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-开发常用命令整理&quot;&gt;&lt;a href=&quot;#Android-开发常用命令整理&quot; class=&quot;headerlink&quot; title=&quot;Android 开发常用命令整理&quot;&gt;&lt;/a&gt;Android 开发常用命令整理&lt;/h1&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Android 应用安全防护和逆向分析》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
      <category term="Android" scheme="http://chennuo.online/tags/Android/"/>
    
      <category term="应用安全防护和逆向分析" scheme="http://chennuo.online/tags/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E5%92%8C%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin笔记-函数与 Lambda 表达式</title>
    <link href="http://chennuo.online/2018/Kotlin/Kotlin%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://chennuo.online/2018/Kotlin/Kotlin笔记-函数与Lambda表达式/</id>
    <published>2018-06-25T02:30:05.000Z</published>
    <updated>2018-06-25T02:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数与-Lambda-表达式笔记"><a href="#函数与-Lambda-表达式笔记" class="headerlink" title="函数与 Lambda 表达式笔记"></a>函数与 Lambda 表达式笔记</h1><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>Kotlin 中的函数使用 fun 关键字声明：</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, off: <span class="type">Int</span> = <span class="number">0</span>, len: <span class="type">Int</span> = b.size)</span></span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; …… &#125;  <span class="comment">// 不能有默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变数量的参数（Varargs）"><a href="#可变数量的参数（Varargs）" class="headerlink" title="可变数量的参数（Varargs）"></a>可变数量的参数（Varargs）</h3><p>函数的参数（通常是最后一个）可以用 vararg 修饰符标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asList</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts) <span class="comment">// ts is an Array</span></span><br><span class="line">        result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许将可变数量的参数传递给函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>当我们调用 <code>vararg</code> 函数时，我们可以一个接一个地传参，例如 <code>asList(1, 2, 3)</code>，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 <code>*</code>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">-1</span>, <span class="number">0</span>, *a, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="中缀表示法"><a href="#中缀表示法" class="headerlink" title="中缀表示法"></a>中缀表示法</h3><p>标有 <code>infix</code> 关键字的函数也可以使用中缀表示法（忽略该调用的点与圆括号）调用。中缀函数必须满足以下要求：</p><ul><li>它们必须是成员函数或扩展函数；</li><li>它们必须只有一个参数；</li><li>其参数不得接受可变数量的参数且不能有默认值。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1.</span>shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>在 Kotlin 中函数可以在文件顶层声明，这意味着你不需要像一些语言如 Java、C# 或 Scala 那样创建一个类来保存一个函数。此外除了顶层函数，Kotlin 中函数也可以声明在局部作用域、作为成员函数以及扩展函数。</p><h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>Kotlin 支持局部函数，即一个函数在另一个函数内部：</p><p>局部函数可以访问外部函数（即闭包）的局部变量</p><h3 id="尾递归函数"><a href="#尾递归函数" class="headerlink" title="尾递归函数"></a>尾递归函数</h3><p>Kotlin 支持一种称为尾递归的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 <code>tailrec</code> 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tailrec <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span></span><br><span class="line">        = <span class="keyword">if</span> (x == Math.cos(x)) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure><p>这段代码计算余弦的不动点（fixpoint of cosine），这是一个数学常数。 它只是重复地从 1.0 开始调用 Math.cos，直到结果不再改变，产生0.7390851332151607的结果。最终代码相当于这种更传统风格的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> y = Math.cos(x)</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x</span><br><span class="line">        x = y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要符合 <code>tailrec</code> 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前尾部递归只在 JVM 后端中支持。</p><h2 id="高阶函数与-lambda-表达式"><a href="#高阶函数与-lambda-表达式" class="headerlink" title="高阶函数与 lambda 表达式"></a>高阶函数与 lambda 表达式</h2><p>Kotlin 函数都是头等的，这意味着它们可以存储在变量与数据结构中、作为参数传递给其他高阶函数以及从其他高阶函数返回。可以像操作任何其他非函数值一样操作函数。</p><p>为促成这点，作为一门静态类型编程语言的 Kotlin 使用一系列函数类型来表示函数并提供一组特定的语言结构，例如 lambda 表达式。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是将函数用作参数或返回值的函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">fold</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    initial: <span class="type">R</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    combine: (<span class="type">acc</span>: <span class="type">R</span>, nextElement: <span class="type">T</span>)</span></span> -&gt; R</span><br><span class="line">): R &#123;</span><br><span class="line">    <span class="keyword">var</span> accumulator: R = initial</span><br><span class="line">    <span class="keyword">for</span> (element: T <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">        accumulator = combine(accumulator, element)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> items = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambdas 表达式是花括号括起来的代码块。</span></span><br><span class="line">    items.fold(<span class="number">0</span>, &#123;</span><br><span class="line">        <span class="comment">// 如果一个 lambda 表达式有参数，前面是参数，后跟“-&gt;”</span></span><br><span class="line">        acc: <span class="built_in">Int</span>, i: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        print(<span class="string">"acc = <span class="variable">$acc</span>, i = <span class="variable">$i</span>, "</span>)</span><br><span class="line">        <span class="keyword">val</span> result = acc + i</span><br><span class="line">        println(<span class="string">"result = <span class="variable">$result</span>"</span>)</span><br><span class="line">        <span class="comment">// lambda 表达式中的最后一个表达式是返回值：</span></span><br><span class="line">        result</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda 表达式的参数类型是可选的，如果能够推断出来的话：</span></span><br><span class="line">    <span class="keyword">val</span> joinedToString = items.fold(<span class="string">"Elements:"</span>, &#123; acc, i -&gt; acc + <span class="string">" "</span> + i &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数引用也可以用于高阶函数调用：</span></span><br><span class="line">    <span class="keyword">val</span> product = items.fold(<span class="number">1</span>, <span class="built_in">Int</span>::times)</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">    println(<span class="string">"joinedToString = <span class="variable">$joinedToString</span>"</span>)</span><br><span class="line">    println(<span class="string">"product = <span class="variable">$product</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">acc = <span class="number">0</span>, i = <span class="number">1</span>, result = <span class="number">1</span></span><br><span class="line">acc = <span class="number">1</span>, i = <span class="number">2</span>, result = <span class="number">3</span></span><br><span class="line">acc = <span class="number">3</span>, i = <span class="number">3</span>, result = <span class="number">6</span></span><br><span class="line">acc = <span class="number">6</span>, i = <span class="number">4</span>, result = <span class="number">10</span></span><br><span class="line">acc = <span class="number">10</span>, i = <span class="number">5</span>, result = <span class="number">15</span></span><br><span class="line">joinedToString = Elements: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">product = <span class="number">120</span></span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>Kotlin 使用类似 (Int) -&gt; String 的一系列函数类型来处理函数的声明： val onClick: () -&gt; Unit = ……。</p><p>这些类型具有与函数签名相对应的特殊表示法，即它们的参数和返回值：</p><blockquote><p>如需将函数类型指定为可空，请使用圆括号：((Int, Int) -&gt; Int)?。<br>箭头表示法是右结合的，(Int) -&gt; (Int) -&gt; Unit 与前述示例等价，但不等于 ((Int) -&gt; (Int)) -&gt; Unit。</p></blockquote><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> oddLength = compose(::isOdd, ::length)</span><br><span class="line">    <span class="keyword">val</span> strings = listOf(<span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span>)</span><br><span class="line">    println(strings.filter(oddLength))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span> = x % <span class="number">2</span> != <span class="number">0</span> <span class="comment">//求基数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">length</span><span class="params">(s: <span class="type">String</span>)</span></span> = s.length</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;A, B, C&gt;</span> <span class="title">compose</span> <span class="params">(  f: (<span class="type">B</span>)</span></span> -&gt; C  ,  g: (A) -&gt; B  )  : (A) -&gt; C &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; x -&gt; f(g(x)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;String, Int, Boolean&gt;</span> <span class="title">compose2</span> <span class="params">(  f: (<span class="type">Int</span>)</span></span> -&gt; <span class="built_in">Boolean</span>  ,  g: (String) -&gt; <span class="built_in">Int</span>  )  : (String) -&gt; <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; x -&gt; f(g(x)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[a,abc]</span><br></pre></td></tr></table></figure><h3 id="Lambda-表达式语法"><a href="#Lambda-表达式语法" class="headerlink" title="Lambda 表达式语法"></a>Lambda 表达式语法</h3><p>Lambda 表达式的完整语法形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br></pre></td></tr></table></figure><p>如果我们把所有可选标注都留下，看起来如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x, y -&gt; x + y &#125;</span><br></pre></td></tr></table></figure><h3 id="将-lambda-表达式传给最后一个参数"><a href="#将-lambda-表达式传给最后一个参数" class="headerlink" title="将 lambda 表达式传给最后一个参数"></a>将 lambda 表达式传给最后一个参数</h3><p>在 Kotlin 中有一个约定：如果函数的最后一个参数接受函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> product = items.fold(<span class="number">1</span>) &#123; acc, e -&gt; acc * e &#125;</span><br></pre></td></tr></table></figure><p>如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run &#123; println(<span class="string">"..."</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="it：单个参数的隐式名称"><a href="#it：单个参数的隐式名称" class="headerlink" title="it：单个参数的隐式名称"></a><code>it</code>：单个参数的隐式名称</h3><p>一个 lambda 表达式只有一个参数是很常见的。</p><p>如果编译器自己可以识别出签名，也可以不用声明唯一的参数并忽略 <code>-&gt;</code>。 该参数会隐式声明为 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.filter &#123; it &gt; <span class="number">0</span> &#125; <span class="comment">// 这个字面值是“(it: Int) -&gt; Boolean”类型的</span></span><br></pre></td></tr></table></figure><h3 id="从-lambda-表达式中返回一个值"><a href="#从-lambda-表达式中返回一个值" class="headerlink" title="从 lambda 表达式中返回一个值"></a>从 lambda 表达式中返回一个值</h3><p>我们可以使用限定的返回语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。</p><p>因此，以下两个片段是等价的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ints.filter &#123;</span><br><span class="line">    <span class="keyword">val</span> shouldFilter = it &gt; <span class="number">0</span></span><br><span class="line">    shouldFilter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ints.filter &#123;</span><br><span class="line">    <span class="keyword">val</span> shouldFilter = it &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span><span class="symbol">@filter</span> shouldFilter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下划线用于未使用的变量"><a href="#下划线用于未使用的变量" class="headerlink" title="下划线用于未使用的变量"></a>下划线用于未使用的变量</h3><p>如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach &#123; _, value -&gt; println(<span class="string">"<span class="variable">$value</span>!"</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Lambda 表达式或者匿名函数（以及局部函数和对象表达式） 可以访问其 闭包 ，即在外部作用域中声明的变量。 与 Java 不同的是可以修改闭包中捕获的变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">ints.filter &#123; it &gt; <span class="number">0</span> &#125;.forEach &#123;</span><br><span class="line">    sum += it</span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。</p><p>但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况：</p><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/inline-functions.html" target="_blank" rel="noopener">内联函数</a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器！）上调度执行，而代码则保持如同顺序执行一样简单。</p><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当我们调用标记有特殊修饰符 suspend 的函数时，会发生挂起：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suspend <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(foo: <span class="type">Foo</span>)</span></span>: Bar &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的函数称为挂起函数，因为调用它们可能挂起协程（如果相关调用的结果已经可用，库可以决定继续进行而不挂起）。挂起函数能够以与普通函数相同的方式获取参数和返回值，但它们只能从协程、其他挂起函数以及内联到其中的函数字面值中调用。</p><p>事实上，要启动协程，必须至少有一个挂起函数，它通常是匿名的（即它是一个挂起 lambda 表达式）。让我们来看一个例子，一个简化的 async() 函数（源自 kotlinx.coroutines 库）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">async</span><span class="params">(block: <span class="type">suspend</span> ()</span></span> -&gt; T)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数与-Lambda-表达式笔记&quot;&gt;&lt;a href=&quot;#函数与-Lambda-表达式笔记&quot; class=&quot;headerlink&quot; title=&quot;函数与 Lambda 表达式笔记&quot;&gt;&lt;/a&gt;函数与 Lambda 表达式笔记&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
      <category term="Kotlin" scheme="http://chennuo.online/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin笔记-类与对象（下）</title>
    <link href="http://chennuo.online/2018/Kotlin/Kotlin%E7%AC%94%E8%AE%B0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://chennuo.online/2018/Kotlin/Kotlin笔记-类与对象（下）/</id>
    <published>2018-06-23T02:30:12.000Z</published>
    <updated>2018-06-23T02:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-类与对象笔记（下）"><a href="#Kotlin-类与对象笔记（下）" class="headerlink" title="Kotlin 类与对象笔记（下）"></a>Kotlin 类与对象笔记（下）</h1><a id="more"></a><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Java 类型系统中最棘手的部分之一是通配符类型（参见 Java Generics FAQ）。 而 Kotlin 中没有。 相反，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）。</p><h3 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h3><p>消费者 in, 生产者 out!</p><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/generics.html" target="_blank" rel="noopener">声明处型变</a></p><h3 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123;</span><br><span class="line"> <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(dest: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">String</span>&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="星投影-–-看不懂。。。"><a href="#星投影-–-看不懂。。。" class="headerlink" title="星投影 – 看不懂。。。"></a>星投影 – 看不懂。。。</h3><h3 id="泛型约束-上界"><a href="#泛型约束-上界" class="headerlink" title="泛型约束 上界"></a>泛型约束 上界</h3><p>最常见的约束类型是与 Java 的 extends 关键字对应的 上界：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒号之后指定的类型是上界：只有 Comparable<t> 的子类型可以替代 T。 例如：</t></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure><p>默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    where T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>枚举类的最基本的用法是实现类型安全的枚举：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Direction</span> </span>&#123;</span><br><span class="line">    NORTH, SOUTH, WEST, EAST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像在 Java 中一样，Kotlin 中的枚举类也有合成方法允许列出定义的枚举常量以及通过名称获取枚举常量。这些方法的签名如下（假设枚举类的名称是 EnumClass）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EnumClass.valueOf(value: String): EnumClass</span><br><span class="line">EnumClass.values(): Array&lt;EnumClass&gt;</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。 Java 用匿名内部类 处理这种情况。 Kotlin 用对象表达式和对象声明对这个概念稍微概括了下。</p><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(x: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">open</span> <span class="keyword">val</span> y: <span class="built_in">Int</span> = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;……&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ab: A = <span class="keyword">object</span> : A(<span class="number">1</span>), B &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y = <span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> adHoc = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> y: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(adHoc.x + adHoc.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有函数，所以其返回类型是匿名对象类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有函数，所以其返回类型是 Any</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">publicFoo</span><span class="params">()</span></span> = <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x: String = <span class="string">"x"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> x1 = foo().x        <span class="comment">// 没问题</span></span><br><span class="line">        <span class="keyword">val</span> x2 = publicFoo().x  <span class="comment">// 错误：未能解析的引用“x”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像 Java 匿名内部类一样，对象表达式中的代码可以访问来自包含它的作用域的变量。 （与 Java 不同的是，这不仅限于 final 变量。）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">countClicks</span><span class="params">(window: <span class="type">JComponent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clickCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> enterCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    window.addMouseListener(<span class="keyword">object</span> : MouseAdapter() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseClicked</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            clickCount++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mouseEntered</span><span class="params">(e: <span class="type">MouseEvent</span>)</span></span> &#123;</span><br><span class="line">            enterCount++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><p>单例模式在一些场景中很有用， 而 Kotlin（继 Scala 之后）使单例声明变得很容易：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这称为对象声明。并且它总是在 object 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。</p><p>对象声明的初始化过程是线程安全的。</p><p>如需引用该对象，我们直接使用其名称即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(……)</span><br></pre></td></tr></table></figure><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>类内部的对象声明可以用 <code>companion</code> 关键字标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该伴生对象的成员可通过只使用类名作为限定符来调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure><p>可以省略伴生对象的名称，在这种情况下将使用名称 <code>Companion</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure><p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Factory&lt;MyClass&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。</p><h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行（及初始化）的；</li><li>对象声明是在第一次被访问到时延迟初始化的；</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。</li></ul><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/delegation.html" target="_blank" rel="noopener">委托</a></p><h3 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h3><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/delegated-properties.html" target="_blank" rel="noopener">委托属性</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-类与对象笔记（下）&quot;&gt;&lt;a href=&quot;#Kotlin-类与对象笔记（下）&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 类与对象笔记（下）&quot;&gt;&lt;/a&gt;Kotlin 类与对象笔记（下）&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="Kotlin" scheme="http://chennuo.online/categories/Android/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://chennuo.online/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin笔记-类与对象（上）</title>
    <link href="http://chennuo.online/2018/Kotlin/Kotlin%E7%AC%94%E8%AE%B0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://chennuo.online/2018/Kotlin/Kotlin笔记-类与对象（上）/</id>
    <published>2018-06-22T02:30:12.000Z</published>
    <updated>2018-06-22T02:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-类与对象笔记（上）"><a href="#Kotlin-类与对象笔记（上）" class="headerlink" title="Kotlin 类与对象笔记（上）"></a>Kotlin 类与对象笔记（上）</h1><a id="more"></a><h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Kotlin 中使用关键字 <code>class</code> 声明类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在 Kotlin 中的一个类可以有一个<strong>主构造函数</strong>和一个或多个<strong>次构造函数</strong>。主构造函数是类头的一部分：它跟在类名（和可选的类型参数）后。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 <span class="keyword">constructor</span> 关键字。</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span> 可省略</span><br></pre></td></tr></table></figure><p>主构造函数不能包含任何的代码。初始化的代码可以放到以 <code>init</code> 关键字作为前缀的 <strong>初始化块</strong>（initializer blocks）中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(firstName: String) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> firstProperty = <span class="string">"First property: <span class="variable">$name</span>"</span>.also(::println)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(<span class="string">"First initializer block that prints <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">public</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(name: String) &#123; …… &#125;</span><br></pre></td></tr></table></figure><h3 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h3><p>类也可以声明前缀有 <code>constructor</code> 的<strong>次构造函数</strong>：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(parent: Person) &#123;</span><br><span class="line">        parent.children.add(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>要创建一个类的实例，我们就像普通函数一样调用构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> invoice = Invoice()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> customer = Customer(<span class="string">"Joe Smith"</span>)</span><br></pre></td></tr></table></figure><p>注意 Kotlin 并没有 <code>new</code> 关键字。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 Kotlin 中所有类都有一个共同的超类 <code>Any</code>，这对于没有超类型声明的类是默认超类：</p><blockquote><p>注意：Any 并不是 java.lang.Object；尤其是，它除了 equals()、hashCode()和toString()外没有任何成员。</p></blockquote><p>类上的 open 标注与 Java 中 final 相反，它允许其他类从这个类继承。默认情况下，在 Kotlin 中所有的类都是 final</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(p: <span class="built_in">Int</span>) <span class="comment">// Base 需为 open 才可以被 Derived 继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(p: <span class="built_in">Int</span>) : Base(p)</span><br></pre></td></tr></table></figure><h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nv</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Derived.v() 函数上必须加上 override标注。如果没写，编译器将会报错。 如果函数没有标注 open 如 Base.nv()，则子类中不允许定义相同签名的函数， 不论加不加 override。在一个 final 类中（没有用 open 标注的类），开放成员是禁止的。<br>标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherDerived</span></span>() : Base() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖属性"><a href="#覆盖属性" class="headerlink" title="覆盖属性"></a>覆盖属性</h3><p>你可以用一个 var 属性覆盖一个 val 属性，但反之则不行。</p><p>你可以在主构造函数中使用 override 关键字作为属性声明的一部分。</p><h3 id="派生类初始化顺序"><a href="#派生类初始化顺序" class="headerlink" title="派生类初始化顺序"></a>派生类初始化顺序</h3><p>在构造派生类的新实例的过程中，第一步完成其基类的初始化（在之前只有对基类构造函数参数的求值），因此发生在派生类的初始化逻辑运行之前。</p><p>例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123; println(<span class="string">"Initializing Base"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> =</span><br><span class="line">        name.length.also &#123; println(<span class="string">"Initializing size in Base: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(</span><br><span class="line">    name: String,</span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line">) : Base(name.capitalize().also &#123; println(<span class="string">"Argument for Base: <span class="variable">$it</span>"</span>) &#125;) &#123;</span><br><span class="line"></span><br><span class="line">    init &#123; println(<span class="string">"Initializing Derived"</span>) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> size: <span class="built_in">Int</span> =</span><br><span class="line">        (<span class="keyword">super</span>.size + lastName.length).also &#123; println(<span class="string">"Initializing size in Derived: <span class="variable">$it</span>"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Constructing Derived(\"hello\", \"world\")"</span>)</span><br><span class="line">    <span class="keyword">val</span> d = Derived(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Constructing Derived(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">Argument <span class="keyword">for</span> Base: Hello</span><br><span class="line">Initializing Base</span><br><span class="line">Initializing size <span class="keyword">in</span> Base: <span class="number">5</span></span><br><span class="line">Initializing Derived</span><br><span class="line">Initializing size <span class="keyword">in</span> Derived: <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>这意味着，基类构造函数执行时，派生类中声明或覆盖的属性都还没有初始化。如果在基类初始化逻辑中（直接或通过另一个覆盖的 open 成员的实现间接）使用了任何一个这种属性，那么都可能导致不正确的行为或运行时故障。设计一个基类时，应该避免在构造函数、属性初始化器以及 init 块中使用 open 成员。</p><h3 id="调用超类实现"><a href="#调用超类实现" class="headerlink" title="调用超类实现"></a>调用超类实现</h3><p>派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：</p><p>在一个内部类中访问外部类的超类，可以通过由外部类名限定的 <code>super</code> 关键字来实现：super@Outer：</p><h3 id="覆盖规则"><a href="#覆盖规则" class="headerlink" title="覆盖规则"></a>覆盖规则</h3><p>在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<base>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"A"</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123; print(<span class="string">"a"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123; print(<span class="string">"B"</span>) &#125; <span class="comment">// 接口成员默认就是“open”的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123; print(<span class="string">"b"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>() : A(), B &#123;</span><br><span class="line">    <span class="comment">// 编译器要求覆盖 f()：</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.f() <span class="comment">// 调用 A.f()</span></span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.f() <span class="comment">// 调用 B.f()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时继承 A 和 B 没问题，并且 a() 和 b() 也没问题因为 C 只继承了每个函数的一个实现。 但是 f() 由 C 继承了两个实现，所以我们必须在 C 中覆盖 f() 并且提供我们自己的实现来消除歧义。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>类和其中的某些成员可以声明为 <code>abstract</code>。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 <code>open</code> 标注一个抽象类或者函数——因为这不言而喻。</p><p>我们可以用一个抽象成员覆盖一个非抽象的开放成员</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>与 Java 或 C# 不同，在 Kotlin 中类没有静态方法。在大多数情况下，它建议简单地使用包级函数。</p><p>如果你需要写一个可以无需用一个类的实例来调用、但需要访问类内部的函数（例如，工厂方法），你可以把它写成该类内对象声明中的一员。</p><p>更具体地讲，如果在你的类内声明了一个伴生对象， 你就可以使用像在 Java/C# 中调用静态方法相同的语法来调用其成员，只使用类名作为限定符。</p><h2 id="属性与字段"><a href="#属性与字段" class="headerlink" title="属性与字段"></a>属性与字段</h2><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/properties.html" target="_blank" rel="noopener">属性与字段</a></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用关键字 <code>interface</code> 来定义接口</p><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> : <span class="type">Named &#123;</span></span></span><br><span class="line">    <span class="keyword">val</span> firstName: String</span><br><span class="line">    <span class="keyword">val</span> lastName: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String <span class="keyword">get</span>() = <span class="string">"<span class="variable">$firstName</span> <span class="variable">$lastName</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>(</span><br><span class="line">    <span class="comment">// 不必实现“name”</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> firstName: String,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> lastName: String,</span><br><span class="line">    <span class="keyword">val</span> position: Position</span><br><span class="line">) : Person</span><br></pre></td></tr></table></figure><h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><p>类、对象、接口、构造函数、方法、属性和它们的 setter 都可以有 可见性修饰符。 （getter 总是与属性有着相同的可见性。） 在 Kotlin 中有这四个可见性修饰符：<code>private</code>、 <code>protected</code>、 <code>internal</code> 和 <code>public</code>。 如果没有显式指定修饰符的话，默认可见性是 <code>public</code>。</p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>函数、属性和类、对象和接口可以在顶层声明，即直接在包内：</p><ul><li>如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；</li><li>如果你声明为 private，它只会在声明它的文件内可见；</li><li>如果你声明为 internal，它会在相同模块内随处可见；</li><li>protected 不适用于顶层声明。</li></ul><p>注意：要使用另一包中可见的顶层声明，仍需将其导入进来。</p><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>对于类内部声明的成员：</p><ul><li>private 意味着只在这个类内部（包含其所有成员）可见；</li><li>protected—— 和 private一样 + 在子类中可见。</li><li>internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；</li><li>public —— 能见到类声明的任何客户端都可见其 public 成员。</li></ul><p>注意 对于Java用户：Kotlin 中外部类不能访问内部类的 private 成员。</p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 <code>constructor</code> 关键字）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(a: <span class="built_in">Int</span>) &#123; …… &#125;</span><br></pre></td></tr></table></figure><p>这里的构造函数是私有的。默认情况下，所有构造函数都是 <code>public</code>，这实际上等于类可见的地方它就可见（即 一个 <code>internal</code> 类的构造函数只能在相同模块内可见).</p><h3 id="局部声明"><a href="#局部声明" class="headerlink" title="局部声明"></a>局部声明</h3><p>局部变量、函数和类不能有可见性修饰符。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>可见性修饰符 <code>internal</code> 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：</p><ul><li>一个 IntelliJ IDEA 模块；</li><li>一个 Maven 项目；</li><li>一个 Gradle 源集（例外是 test 源集可以访问 main 的 internal 声明）；</li><li>一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。</p><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。</p><h3 id="扩展是静态解析的"><a href="#扩展是静态解析的" class="headerlink" title="扩展是静态解析的"></a>扩展是静态解析的</h3><p>扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。</p><p>我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"c"</span> <span class="comment">// 扩展</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">"d"</span> <span class="comment">// 扩展</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">    println(c.foo())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFoo(D())</span><br><span class="line"></span><br><span class="line">这个例子会输出 <span class="string">"c"</span>，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。</span><br></pre></td></tr></table></figure><p>如果一个类定义有一个成员函数和一个扩展函数，而这两个函数又有相同的接收者类型、相同的名字并且都适用给定的参数，这种情况总是取成员函数。 例如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"member"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">"extension"</span>) &#125;</span><br><span class="line"></span><br><span class="line">如果我们调用 C 类型 c的 c.foo()，它将输出“member”，而不是“extension”。</span><br></pre></td></tr></table></figure></p><h3 id="可空接收者"><a href="#可空接收者" class="headerlink" title="可空接收者"></a>可空接收者</h3><p>注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 <code>this == null</code>，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Any?.<span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"null"</span></span><br><span class="line">    <span class="comment">// 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()</span></span><br><span class="line">    <span class="comment">// 解析为 Any 类的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>和函数类似，Kotlin 支持扩展属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="伴生对象的扩展"><a href="#伴生对象的扩展" class="headerlink" title="伴生对象的扩展"></a>伴生对象的扩展</h3><p>如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数和属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 "Companion"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像伴生对象的其他普通成员，只需用类名作为限定符去调用他们</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass.foo()</span><br></pre></td></tr></table></figure><h3 id="扩展的作用域"><a href="#扩展的作用域" class="headerlink" title="扩展的作用域"></a>扩展的作用域</h3><p><a href="https://hltj.gitbooks.io/kotlin-reference-chinese/content/txt/extensions.html" target="_blank" rel="noopener">扩展的作用域</a></p><h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 <code>data</code>：</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(name: <span class="type">String</span> = this.name, age: <span class="type">Int</span> = this.age)</span></span> = User(name, age)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> jack = User(name = <span class="string">"Jack"</span>, age = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="数据类和解构声明"><a href="#数据类和解构声明" class="headerlink" title="数据类和解构声明"></a>数据类和解构声明</h3><p>为数据类生成的 Component 函数 使它们可在解构声明中使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jane = User(<span class="string">"Jane"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="keyword">val</span> (name, age) = jane</span><br><span class="line">println(<span class="string">"<span class="variable">$name</span>, <span class="variable">$age</span> years of age"</span>) <span class="comment">// 输出 "Jane, 35 years of age"</span></span><br></pre></td></tr></table></figure><h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类用来表示受限的类继承结构：当一个值为有限集中的类型、而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。</p><p>要声明一个密封类，需要在类名前面添加 <code>sealed</code> 修饰符。虽然密封类也可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br></pre></td></tr></table></figure><p>（上文示例使用了 Kotlin 1.1 的一个额外的新功能：数据类扩展包括密封类在内的其他类的可能性。 ）</p><p>一个密封类是自身抽象的，它不能直接实例化并可以有抽象（<code>abstract</code>）成员。</p><p>密封类不允许有非 - <code>private</code> 构造函数（其构造函数默认为 <code>private</code>）。</p><p>请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。</p><p>使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 <code>else</code> 子句了。当然，这只有当你用 <code>when</code> 作为表达式（使用结果）而不是作为语句时才有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span>(expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">    <span class="comment">// 不再需要 `else` 子句，因为我们已经覆盖了所有的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-类与对象笔记（上）&quot;&gt;&lt;a href=&quot;#Kotlin-类与对象笔记（上）&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 类与对象笔记（上）&quot;&gt;&lt;/a&gt;Kotlin 类与对象笔记（上）&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="Kotlin" scheme="http://chennuo.online/categories/Android/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://chennuo.online/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin笔记-基础</title>
    <link href="http://chennuo.online/2018/Kotlin/Kotlin%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/"/>
    <id>http://chennuo.online/2018/Kotlin/Kotlin笔记-基础/</id>
    <published>2018-06-22T01:30:12.000Z</published>
    <updated>2018-06-22T01:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kotlin-语法基础"><a href="#Kotlin-语法基础" class="headerlink" title="Kotlin 语法基础"></a>Kotlin 语法基础</h1><a id="more"></a><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>在 Kotlin 中，所有东西都是对象，在这个意义上讲我们可以在任何变量上调用成员函数和属性。 一些类型可以有特殊的内部表示——例如，数字、字符和布尔值可以在运行时表示为原生类型值，但是对于用户来说，它们看起来就像普通的类。 在本节中，我们会描述 Kotlin 中使用的基本类型：数字、字符、布尔值、数组与字符串。</p><h3 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h3><p>在 Java 平台数字是物理存储为 JVM 的原生类型，除非我们需要一个可空的引用（如 <code>Int?</code> ）或泛型。 后者情况下会把数字装箱。</p><p>注意数字装箱不必保留同一性:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span></span><br><span class="line">print(a === a) <span class="comment">// 输出“true”</span></span><br><span class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a</span><br><span class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a</span><br><span class="line">print(boxedA === anotherBoxedA) <span class="comment">// ！！！输出“false”！！！</span></span><br></pre></td></tr></table></figure><p>另一方面，它保留了相等性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a: Int = 10000</span><br><span class="line">print(a == a) // 输出“true”</span><br><span class="line">val boxedA: Int? = a</span><br><span class="line">val anotherBoxedA: Int? = a</span><br><span class="line">print(boxedA == anotherBoxedA) // 输出“true”</span><br></pre></td></tr></table></figure><h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3><p>由于不同的表示方式，较小类型并不是较大类型的子类型。 如果它们是的话，就会出现下述问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假想的代码，实际上并不能编译：</span><br><span class="line">val a: Int? = 1 // 一个装箱的 Int (java.lang.Integer)</span><br><span class="line">val b: Long? = a // 隐式转换产生一个装箱的 Long (java.lang.Long)</span><br><span class="line">print(b == a) // 惊！这将输出“false”鉴于 Long 的 equals() 会检测另一个是否也为 Long</span><br></pre></td></tr></table></figure><p>所以相等性会在所有地方悄无声息地失去，更别说同一性了。</p><p>因此较小的类型不能隐式转换为较大的类型。 这意味着在不进行显式转换的情况下我们不能把 Byte 型值赋给一个 Int 变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val b: Byte = 1 // OK, 字面值是静态检测的</span><br><span class="line">val i: Int = b // 错误</span><br></pre></td></tr></table></figure><p>我们可以显式转换来拓宽数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val i: Int = b.toInt() // OK: 显式拓宽</span><br></pre></td></tr></table></figure><p>每个数字类型支持如下的转换:</p><ul><li>toByte(): Byte</li><li>toShort(): Short</li><li>toInt(): Int</li><li>toLong(): Long</li><li>toFloat(): Float</li><li>toDouble(): Double</li><li>toChar(): Char</li></ul><p>缺乏隐式类型转换并不显著，因为类型会从上下文推断出来，而算术运算会有重载做适当转换，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val l = 1L + 3 // Long + Int =&gt; Long</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Kotlin支持数字运算的标准集，运算被定义为相应的类成员（但编译器会将函数调用优化为相应的指令）。</p><p>对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val x = (1 shl 2) and 0x000FF000</span><br></pre></td></tr></table></figure><p>这是完整的位运算列表（只用于 Int 和 Long）：</p><ul><li>shl(bits) – 有符号左移 (Java 的 &lt;&lt;)</li><li>shr(bits) – 有符号右移 (Java 的 &gt;&gt;)</li><li>ushr(bits) – 无符号右移 (Java 的 &gt;&gt;&gt;)</li><li>and(bits) – 位与</li><li>or(bits) – 位或</li><li>xor(bits) – 位异或</li><li>inv() – 位非</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组在 Kotlin 中使用 <code>Array</code> 类来表示，它定义了 <code>get</code> 和 <code>set</code> 函数（按照运算符重载约定这会转变为 <code>[]</code>）和 <code>size</code> 属性，以及一些其他有用的成员函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Array&lt;T&gt; private constructor() &#123;</span><br><span class="line">    val size: Int</span><br><span class="line">    operator fun get(index: Int): T</span><br><span class="line">    operator fun set(index: Int, value: T): Unit</span><br><span class="line"></span><br><span class="line">    operator fun iterator(): Iterator&lt;T&gt;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用库函数 <code>arrayOf()</code> 来创建一个数组并传递元素值给它，这样 <code>arrayOf(1, 2, 3)</code> 创建了 <code>array [1, 2, 3]</code>。 或者，库函数 <code>arrayOfNulls()</code> 可以用于创建一个指定大小的、所有元素都为空的数组。</p><p>另一个选项是用接受数组大小和一个函数参数的 <code>Array</code> 构造函数，用作参数的函数能够返回给定索引的每个元素初始值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个 Array&lt;String&gt; 初始化为 [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]</span><br><span class="line">val asc = Array(5, &#123; i -&gt; (i * i).toString() &#125;)</span><br></pre></td></tr></table></figure><p>注意: 与 Java 不同的是，Kotlin 中数组是不型变的（invariant）。这意味着 Kotlin 不让我们把 <code>Array&lt;String&gt;</code> 赋值给 <code>Array&lt;Any&gt;</code>，以防止可能的运行时失败（但是你可以使用 <code>Array&lt;out Any&gt;</code>, 参见类型投影）。</p><p>Kotlin 也有无装箱开销的专门的类来表示原生类型数组: <code>ByteArray</code>、 <code>ShortArray</code>、<code>IntArray</code> 等等。这些类和 <code>Array</code> 并没有继承关系，但是它们有同样的方法属性集。它们也都有相应的工厂方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val x: IntArray = intArrayOf(1, 2, 3)</span><br><span class="line">x[0] = x[1] + x[2]</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串用 <code>String</code> 类型表示。字符串是不可变的。 字符串的元素——字符可以使用索引运算符访问: <code>s[i]</code>。 可以用 <code>for</code> 循环迭代字符串:</p><p>请注意，在大多数情况下，优先使用 <code>字符串模板</code> 或 <code>原始字符串</code> 而不是字符串连接。</p><h3 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h3><p>Kotlin 有两种类型的字符串字面值: 转义字符串可以有转义字符，以及原始字符串可以包含换行和任意文本。</p><p>原始字符串 使用三个引号（<code>&quot;&quot;&quot;</code>）分界符括起来，内部 <code>没有转义</code> 并且可以包含换行和任何其他字符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//输入值</span><br><span class="line">val text = &quot;&quot;&quot;</span><br><span class="line">    for (c in &quot;foo&quot;)</span><br><span class="line">        print(c)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">//输出值</span><br><span class="line">    for (c in &quot;foo&quot;)</span><br><span class="line">        print(c)</span><br></pre></td></tr></table></figure><p>你可以通过 <code>trimMargin()</code> 函数去除前导空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//输入值</span><br><span class="line">val text = &quot;&quot;&quot;</span><br><span class="line">    |Tell me and I forget.</span><br><span class="line">     Teach me and I remember.</span><br><span class="line">    |Involve me and I learn.</span><br><span class="line">    |(Benjamin Franklin)</span><br><span class="line">    &quot;&quot;&quot;.trimMargin()</span><br><span class="line"></span><br><span class="line">//输出值</span><br><span class="line">Tell me and I forget.</span><br><span class="line">    Teach me and I remember.</span><br><span class="line">Involve me and I learn.</span><br><span class="line">(Benjamin Franklin)</span><br></pre></td></tr></table></figure><p>默认 <code>|</code> 用作边界前缀，但你可以选择其他字符并作为参数传入，比如 <code>trimMargin(&quot;&gt;&quot;)</code>。</p><h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>字符串可以包含模板表达式 ，即一些小段代码，会求值并把结果合并到字符串中。 模板表达式以美元符（<code>$</code>）开头，由一个简单的名字构成:</p><p>原始字符串和转义字符串内部都支持模板。 如果你需要在原始字符串中表示字面值 <code>$</code> 字符（它不支持反斜杠转义），你可以用下列语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//输入值</span><br><span class="line">val price = &quot;&quot;&quot;</span><br><span class="line">$&#123;&apos;$&apos;&#125;9.99</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">//输出值</span><br><span class="line">$9.99</span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h3><p>有多个包会默认导入到每个 Kotlin 文件中：</p><ul><li>kotlin.*</li><li>kotlin.annotation.*</li><li>kotlin.collections.*</li><li>kotlin.comparisons.* （自 1.1 起）</li><li>kotlin.io.*</li><li>kotlin.ranges.*</li><li>kotlin.sequences.*</li><li>kotlin.text.*</li></ul><p>根据目标平台还会导入额外的包：</p><ul><li>JVM:<ul><li>java.lang.*</li><li>kotlin.jvm.*</li></ul></li><li>JS:<ul><li>kotlin.js.*</li></ul></li></ul><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果出现名字冲突，可以使用 <code>as</code> 关键字在本地重命名冲突项来消歧义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import foo.Bar // Bar 可访问</span><br><span class="line">import bar.Bar as bBar // bBar 代表“bar.Bar”</span><br></pre></td></tr></table></figure><p>关键字 <code>import</code> 并不仅限于导入类；也可用它来导入其他声明：</p><ul><li>顶层函数及属性；</li><li>在对象声明中声明的函数和属性;</li><li>枚举常量。</li></ul><p>与 Java 不同，Kotlin 没有单独的“import static”语法； 所有这些声明都用 <code>import</code> 关键字导入。</p><h3 id="顶层声明的可见性"><a href="#顶层声明的可见性" class="headerlink" title="顶层声明的可见性"></a>顶层声明的可见性</h3><p>如果顶层声明是 <code>private</code> 的，它是声明它的文件所私有的（参见 可见性修饰符）。</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="If-表达式"><a href="#If-表达式" class="headerlink" title="If 表达式"></a>If 表达式</h3><p><code>if</code>的分支可以是代码块，最后的表达式作为该块的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val max = if (a &gt; b) &#123;</span><br><span class="line">    print(&quot;Choose a&quot;)</span><br><span class="line">    a</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;Choose b&quot;)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用 <code>if</code> 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 <code>else</code> 分支。</p><h3 id="When-表达式"><a href="#When-表达式" class="headerlink" title="When 表达式"></a>When 表达式</h3><p><code>when</code> 将它的参数和所有的分支条件顺序比较，直到某个分支满足条件。 <code>when</code> 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 <code>if</code> 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。）</p><p>如果 <code>when</code> 作为一个表达式使用，则必须有 <code>else</code> 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］。</p><p>如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when (x) &#123;</span><br><span class="line">    0, 1 -&gt; print(&quot;x == 0 or x == 1&quot;)</span><br><span class="line">    else -&gt; print(&quot;otherwise&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用任意表达式（而不只是常量）作为分支条件</p><p>我们也可以检测一个值在（<code>in</code>）或者不在（<code>!in</code>）一个区间或者集合中：</p><p>另一种可能性是检测一个值是（<code>is</code>）或者不是（<code>!is</code>）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法和属性而无需任何额外的检测。</p><p><code>when</code> 也可以用来取代 <code>if</code>-<code>else</code> <code>if</code>链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：</p><h3 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h3><p>一些例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (item: <span class="built_in">Int</span> <span class="keyword">in</span> ints) &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array.indices) &#123;</span><br><span class="line">    println(array[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> array.withIndex()) &#123;</span><br><span class="line">    println(<span class="string">"the element at <span class="variable">$index</span> is <span class="variable">$value</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回和跳转"><a href="#返回和跳转" class="headerlink" title="返回和跳转"></a>返回和跳转</h2><p>Kotlin 有三种结构化跳转表达式：</p><ul><li><code>return</code>。默认从最直接包围它的函数或者匿名函数返回。</li><li><code>break</code>。终止最直接包围它的循环。</li><li><code>continue</code>。继续下一次最直接包围它的循环。</li></ul><p>所有这些表达式都可以用作更大表达式的一部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = person.name ?: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这些表达式的类型是 Nothing 类型。</p><h3 id="Break-与-Continue-标签"><a href="#Break-与-Continue-标签" class="headerlink" title="Break 与 Continue 标签"></a>Break 与 Continue 标签</h3><p>在 Kotlin 中任何表达式都可以用标签（<code>label</code>）来标记。 标签的格式为标识符后跟 <code>@</code> 符号，例如：<code>abc@</code>、<code>fooBar@</code>都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。</p><p>现在，我们可以用标签限制 <code>break</code> 或者<code>continue</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span> <span class="comment">//表示跳出整个循环</span></span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">continue</span><span class="symbol">@loop</span> <span class="comment">//表示继续loop循环的下一次迭代，既i++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 <code>continue</code> 继续标签指定的循环的下一次迭代。</p><h3 id="标签处返回"><a href="#标签处返回" class="headerlink" title="标签处返回"></a>标签处返回</h3><p>例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//直接退出循环</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span> <span class="comment">// 非局部直接返回到 foo() 的调用者</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"this point is unreachable"</span>)<span class="comment">//不会输出</span></span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach <span class="symbol">lit@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with explicit label"</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1245</span> done with explicit label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式标签 continue</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with explicit label"</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1245</span> done with explicit label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名函数代替 lambda 表达式 continue</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach(<span class="function"><span class="title">fun</span><span class="params">(value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">3</span>) <span class="keyword">return</span>  <span class="comment">// 局部返回到匿名函数的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    print(<span class="string">" done with anonymous function"</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">1245</span> done with anonymous function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    run <span class="symbol">loop@</span>&#123;</span><br><span class="line">        listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@loop</span> <span class="comment">// 从传入 run 的 lambda 表达式非局部返回</span></span><br><span class="line">            print(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">" done with nested loop"</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">12</span> done with nested loop</span><br></pre></td></tr></table></figure></p><p>当要返一个回值的时候，解析器优先选用标签限制的 return，即</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>意为“从标签 <code>@a</code> 返回 1”，而不是“返回一个标签标注的表达式 <code>(@a 1)</code>”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Kotlin-语法基础&quot;&gt;&lt;a href=&quot;#Kotlin-语法基础&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 语法基础&quot;&gt;&lt;/a&gt;Kotlin 语法基础&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="Kotlin" scheme="http://chennuo.online/categories/Android/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://chennuo.online/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>优秀开源项目记录</title>
    <link href="http://chennuo.online/2018/Android/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>http://chennuo.online/2018/Android/优秀开源项目记录/</id>
    <published>2018-06-04T02:11:31.000Z</published>
    <updated>2018-06-04T02:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优秀开源项目记录"><a href="#优秀开源项目记录" class="headerlink" title="优秀开源项目记录"></a>优秀开源项目记录</h2><a id="more"></a><h3 id="一款采用MVP模式的设计的仿造腾讯漫画的APP"><a href="#一款采用MVP模式的设计的仿造腾讯漫画的APP" class="headerlink" title="一款采用MVP模式的设计的仿造腾讯漫画的APP"></a>一款采用MVP模式的设计的仿造腾讯漫画的APP</h3><p><a href="https://github.com/zhhr1122/z_comic_new" target="_blank" rel="noopener">https://github.com/zhhr1122/z_comic_new</a></p><h3 id="WanAndroid客户端Flutter版"><a href="#WanAndroid客户端Flutter版" class="headerlink" title="WanAndroid客户端Flutter版"></a>WanAndroid客户端Flutter版</h3><p><a href="https://github.com/canhuah/WanAndroid" target="_blank" rel="noopener">https://github.com/canhuah/WanAndroid</a></p><p>在编写该案例过程中，遇到的一些问题，作者也做了总结：</p><p><a href="http://www.canhuah.com/Flutter实战之WanAndroid项目中碰到的问题.html" target="_blank" rel="noopener">http://www.canhuah.com/Flutter实战之WanAndroid项目中碰到的问题.html</a></p><h3 id="基于Flutter的开源中国客户端"><a href="#基于Flutter的开源中国客户端" class="headerlink" title="基于Flutter的开源中国客户端"></a>基于Flutter的开源中国客户端</h3><p><a href="https://github.com/yubo725/flutter-osc" target="_blank" rel="noopener">https://github.com/yubo725/flutter-osc</a></p><h3 id="超完整开源Flutter-Github客户端"><a href="#超完整开源Flutter-Github客户端" class="headerlink" title="超完整开源Flutter Github客户端"></a>超完整开源Flutter Github客户端</h3><p><a href="https://github.com/CarGuo/GSYGithubAppFlutter" target="_blank" rel="noopener">https://github.com/CarGuo/GSYGithubAppFlutter</a></p><h3 id="Android-骨架屏实现"><a href="#Android-骨架屏实现" class="headerlink" title="Android 骨架屏实现"></a>Android 骨架屏实现</h3><p><a href="https://github.com/sharish/ShimmerRecyclerView" target="_blank" rel="noopener">https://github.com/sharish/ShimmerRecyclerView</a></p><p><a href="https://github.com/ethanhua/Skeleton" target="_blank" rel="noopener">https://github.com/ethanhua/Skeleton</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;优秀开源项目记录&quot;&gt;&lt;a href=&quot;#优秀开源项目记录&quot; class=&quot;headerlink&quot; title=&quot;优秀开源项目记录&quot;&gt;&lt;/a&gt;优秀开源项目记录&lt;/h2&gt;
    
    </summary>
    
      <category term="开源项目" scheme="http://chennuo.online/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="开源项目" scheme="http://chennuo.online/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>IPC机制（下）</title>
    <link href="http://chennuo.online/2018/Android/IPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://chennuo.online/2018/Android/IPC机制（下）/</id>
    <published>2018-01-09T13:07:08.000Z</published>
    <updated>2018-01-09T13:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记下篇"><a href="#本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记下篇" class="headerlink" title="本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记下篇"></a>本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记下篇</h1><a id="more"></a><h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><h3 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h3><p>Activity、Service、Receiver 都是支持在 Intent 中传递 Bundle 数据的。例如相机</p><h3 id="使用文件共享"><a href="#使用文件共享" class="headerlink" title="使用文件共享"></a>使用文件共享</h3><p>将某些类序列化成文件存储，通过文件共享信息</p><p>其中使用 SharedPreferences 需要注意，SharedPreferences 是 Android 中采用的轻量级存储方案，它底层通过 XML 文件来存储键值对。但是，由于系统对其读写有一定的缓存策略，即内存中会有一份 SharedPreferences 文件的缓存，因此在多进程模式下，其工作不可靠，面对高并发的读写访问，SharedPreferences 有可能会丢失数据。</p><h3 id="使用-Messenger-信使"><a href="#使用-Messenger-信使" class="headerlink" title="使用 Messenger 信使"></a>使用 Messenger 信使</h3><p>一种轻量级的 IPC 方案，底层实现为 AIDL。</p><p>服务端：构建包含 Handler 的 Messenger ，在 Handler 里面对 Message 进行处理。通过 <code>onBind</code> 返回一个包含服务端调用的 Binder 对象。</p><p>客户端：在 <code>onServiceConnected(ComponentName className, IBinder service)</code> 中拿到服务端的调用 <code>mService = new Messenger(service)</code>， Messenger(IBinder service) 内部实现为 <code>IMessenger.Stub.asInterface(service)</code></p><p>若客户端需要对服务端的通信做出回应，则在发送的时候构建处理返回消息的 Messenger，并在通过 msg.replyto = mMessenger 赋值在传送过去的 Message 对象中，服务端通过获取 msg.replyto 重新获取 Messenger 对象，并对其进行操作，从而完成客户端与服务端之间的通信。</p><h3 id="使用-AIDL"><a href="#使用-AIDL" class="headerlink" title="使用 AIDL"></a>使用 AIDL</h3><p>Messenger 的作用主要是为了传递消息，而很多时候我们需要跨进程调用服务端的方法，这种情况下 Messenger 无法做到，但是我们可以通过 AIDL 来实现跨进程的方法调用。AIDL 也是 Messenger 的底层实现。</p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>服务端首先要创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>首先需要绑定服务端的 Service，绑定成功后，将服务端返回的 Binder 对象转换成 AIDL 接口所属的类型，接着就可以调用 AIDL 中的方法。</p><h4 id="AIDL-接口的创建"><a href="#AIDL-接口的创建" class="headerlink" title="AIDL 接口的创建"></a>AIDL 接口的创建</h4><p>支持类型如下</p><ul><li>基本数据类型（int、long、char、boolean、double等）</li><li>String 和 CharSequence</li><li>List：只支持 ArrayList，里面每个元素都必须能够被 AIDL 支持</li><li>Map：只支持 HashMap，里面每个元素都必须能够被 AIDL 支持，包括 key 和 value</li><li>Parcelable：所有实现了 Parcelable 接口的对象</li><li>AIDL：所有的 AIDL 接口本身也可以在 AIDL 文件中使用</li></ul><p>其中自定义的 Parcelable 对象和 AIDL 对象必须要显示 import 进来，不管是否在同一个包中。如果 AIDL 文件中用到了自定义的 Parcelable 对象，那么必须新建一个和它同名的 AIDL 文件，并在其中声明它为 Parcelable 类型。除此之外，AIDL 中除了基本数据类型，其他类型的参数必须标上方向： <code>in、out、inout</code> 用以表示数据流向</p><h4 id="服务端和客户端的实现"><a href="#服务端和客户端的实现" class="headerlink" title="服务端和客户端的实现"></a>服务端和客户端的实现</h4><p>简单的 C/S 模式下，AIDL 中 List 数据的传递，我们在 Service 中采用 CopyOnWriteArrayList 来完成，它支持并发读/写。我们知道  <code>AIDL 方法是在服务端的 Binder 线程池中执行的</code> ，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在 AIDL 方法中处理线程同步，而 CopyOnWriteArrayList 能帮我们进行自动的线程同步。</p><blockquote><p>前面我们提过 AIDL 中能够使用的 List 只有 ArrayList，但是我们这里却使用 CopyOnWriteArrayList （它并不继承于 ArrayList）。Binder 中会按照 List 的规范去访问数据并最终形成一个新的 ArrayList 传递给客户端。与此类似的还有 ConcurrentHashMap。</p></blockquote><p>我们还可以使用 AIDL 接口，完成观察者模式。对应的应用例如系统服务的监听（定位…）</p><p>对象的跨进程传输本质都是反序列化的过程，所以 AIDL 中自定义对象都必须要实现 Parcelable 接口。<br>RemoteCallbackList 是系统专门提供的用于删除跨进程 listenr 的接口。RemoteCallbackList 是一个泛型，支持管理任意 AIDL 接口。当客户端进程终止后，它能够自动移除客户端所注册的 listener，且内部实现了线程同步的功能。<br>遍历 RemoteCallbackList 需要如下方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = mListenerList.beginBroadcast();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            IOnNewBookArrivedListener listener = mListenerList.getBroadcastItem(i);</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    listener.onNewBookArrived(book);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mListenerList.finishBroadcast();</span><br></pre></td></tr></table></figure><h4 id="AIDL-特别点"><a href="#AIDL-特别点" class="headerlink" title="AIDL 特别点"></a>AIDL 特别点</h4><ul><li>客户端调用远程服务的方法，被调用的方法运行在 Binder 线程池中，所以服务端本身可以执行大量耗时的操作。客户端线程在调用的时候会被挂起，所以调用耗时服务端方法时需另开线程完成。</li><li>客户端的 onServiceConnected 和 onServiceDisconnected 方法都运行在 UI 线程中，不要在其中调用服务端的耗时方法，否则会导致 ANR。</li><li>服务端同样不能调用客户端中的耗时方法</li><li>服务端调用客户端的方法，客户端的方法运行在客户端的 Binder 线程池中，所以不能在里面去访问 UI 相关的内容，需使用 Handler 切换到 UI 线程。</li></ul><h4 id="Binder-死亡处理"><a href="#Binder-死亡处理" class="headerlink" title="Binder 死亡处理"></a>Binder 死亡处理</h4><p>方法一：通过 DeathRecipient 监听，在 binderDied 方法中重连，具体内容见上篇。（binderDied 在客户端的 Binder 线程池中被回调）</p><p>方法二：在 onServiceDisconnected 中重连远程服务。（在客户端的 UI 线程中被回调）</p><h4 id="AIDL-权限验证"><a href="#AIDL-权限验证" class="headerlink" title="AIDL 权限验证"></a>AIDL 权限验证</h4><blockquote><p>定义 permission</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">permission</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">"chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 permission</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>服务端 onBind 验证 permission</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//验证权限</span></span><br><span class="line">    <span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"chennuo.easyview.aidl.permissson.ACCESS_BOOK_SERVICE"</span>);</span><br><span class="line">    <span class="comment">//未授权</span></span><br><span class="line">    <span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mBinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-ContentProvider"><a href="#使用-ContentProvider" class="headerlink" title="使用 ContentProvider"></a>使用 ContentProvider</h3><p>通过数据库的方式进行进程间通信</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h2 id="Binder-连接池"><a href="#Binder-连接池" class="headerlink" title="Binder 连接池"></a>Binder 连接池</h2><p>通过创建一个 Service 即可完成多个 AIDL 接口的工作</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记下篇&quot;&gt;&lt;a href=&quot;#本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记下篇&quot; class=&quot;headerlink&quot; title=&quot;本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记下篇&quot;&gt;&lt;/a&gt;本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记下篇&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="IPC" scheme="http://chennuo.online/categories/Android/IPC/"/>
    
    
      <category term="Android 开发艺术探索" scheme="http://chennuo.online/tags/Android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>IPC 机制（上）</title>
    <link href="http://chennuo.online/2018/Android/IPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://chennuo.online/2018/Android/IPC机制（上）/</id>
    <published>2018-01-07T04:23:56.000Z</published>
    <updated>2018-01-07T04:23:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记上篇"><a href="#本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记上篇" class="headerlink" title="本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记上篇"></a>本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记上篇</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>IPC 是 Inter-Process Communication 的缩写，含义为进程间通信或者跨进程通信，是指两个进程直接进行数据交换的过程。</p><h2 id="Android-中的多进程模式"><a href="#Android-中的多进程模式" class="headerlink" title="Android 中的多进程模式"></a>Android 中的多进程模式</h2><h3 id="开启多进程模式"><a href="#开启多进程模式" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h3><p>给四大组件在 AndroidMenifest 中指定 android:process 属性，除此之外没有其他办法，也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。<br>另：非常规方式，通过 JNI 在 native 层去 fork 一个新的进程。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包名加":remote"--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 属于当前应用的私有进程 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他应用不可以和他跑在同一个进程中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".activity.TestActivity1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 完整进程名--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全局进程 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他应用可以通过 ShareUID 方式可以和它跑在同一个进程中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".activity.TestActivity2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">"com.chennuo.remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以通过 <code>adb shell ps</code> 命令来查看进程信息</p></blockquote><p>我们知道 Android 系统会为每个应用分配一个唯一的 UID， 具有相同 UID 的应用才能共享数据。这里要说明的是，两个应用通过 ShareUID 跑在同一个进程中是有要求的，需要这两个应用有相同的 ShareUID 并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如 data 目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享 data 目录、组件信息，还可以共享内存数据，或者它们看起来就像是一个应用的两个部分。</p><h3 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h3><p>一般来说，使用多进程会造成如下几方面的问题：</p><ul><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences 的可靠性下降</li><li>Application 会多次创建</li></ul><h2 id="IPC-基础概念介绍"><a href="#IPC-基础概念介绍" class="headerlink" title="IPC 基础概念介绍"></a>IPC 基础概念介绍</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><blockquote><p>声明 serialVersionUID 非必须，但是不声明 serialVersionUID 会对反序列化过程带来影响。</p></blockquote><p>序列化的时候，系统会把当前类的 serialVersionUID 写入序列化的文件中（也可能是其他的中介），当反序列化的时候，系统会去检测文件中的 serialVersionUID ，看是否和当前类的一致。如果一致则说明两者版本相同。否则，说明当前类和序列化的类发生了某些变换，会报 <code>java.io.InvalidClassException</code> 错误</p><blockquote><p>我们可以给 serialVersionUID 指定为 1L 或者由 AS 自动生成 serialVersionUID 的 hash 值，两者没有本质区别。</p></blockquote><p>注：</p><ul><li>1.静态成员变量属于类不属于对象，所以不会参与序列化过程</li><li>2.用 transient 关键字标记的成员变量不参与序列化过程</li></ul><h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><blockquote><p>Serializable 是 Java 中的序列化接口，其使用简单但是开销大，序列化和反序列化都需要大量的 I/O 操作。<br>Parcelable 是 Android 中的序列化方式，更适合用于 Android 平台。<br>对比两者，Parcelable 主要用于内存序列化上。Serializable 更适合将序列化到存储设备或者将对象序列化后通过网络传输。</p></blockquote><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>Android 开发中，Binder 主要用在 Service 中，包括 AIDL 和 Messenger，其中普通 Service 中的 Binder 不涉及进程间通信，而 Messenger 的底层其实是 AIDL。所以我们选择用 AIDL 来分析 Binder 的工作机制。</p><h4 id="分析-AIDL"><a href="#分析-AIDL" class="headerlink" title="分析 AIDL"></a>分析 AIDL</h4><p>当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的 <code>transact</code> 过程，而当两者位于不同的进程时，方法调用需要走 <code>transact</code> 过程，这个逻辑由 Stub 的内部代理类 Proxy 来完成。这个接口的核心实现就是它的内部类 Stub 和 Stub 的内部代理类 Proxy。</p><p><strong>DESCRIPTOR</strong><br>Binder 的唯一标识，一般用当前 Binder 的类名表示。</p><p><strong>asInterface(android.os.IBinder obj)</strong><br>用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口类型的对象，这种转换过程是区分进程的。如果两端位于同一进程，则返回服务端的 Stub 对象本身，否则返回的是系统封装后的 Stub.proxy 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cast an IBinder object into an chen.easyview.aidl.IBookManager interface,</span></span><br><span class="line"><span class="comment"> * generating a proxy if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> chen.easyview.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> chen.easyview.aidl.IBookManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((chen.easyview.aidl.IBookManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> chen.easyview.aidl.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>asBinder</strong><br>用于返回当前 Binder 对象</p><p><strong>onTransact</strong><br>该方法运行在服务端中的 Binder 线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。如果此方法返回 false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">            reply.writeString(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            java.util.List&lt;chen.easyview.aidl.Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            reply.writeTypedList(_result);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">            data.enforceInterface(DESCRIPTOR);</span><br><span class="line">            chen.easyview.aidl.Book _arg0;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">                _arg0 = chen.easyview.aidl.Book.CREATOR.createFromParcel(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _arg0 = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">            reply.writeNoException();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proxy#getBookList</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.util.List&lt;chen.easyview.aidl.Book&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.util.List&lt;chen.easyview.aidl.Book&gt; _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.createTypedArrayList(chen.easyview.aidl.Book.CREATOR);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法运行在客户端，当客户端远程调用此方法时，会调用 transact 方法来发起 RPC（远程过程调用） 请求，同时当前线程挂起；然后服务端的 onTransact 方法会被调用，直到 RPC 过程返回后，当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果；最后返回 _reply 中的数据、</p><h4 id="自己写-AIDL"><a href="#自己写-AIDL" class="headerlink" title="自己写 AIDL"></a>自己写 AIDL</h4><p>AIDL 不是实现 Binder 的必需品。如果是我们手写的 Binder，那么在服务端只需要创建一个 BookManagerImpl 的对象并在 Service 的 onBind 方法中返回即可。</p><h3 id="Binder-的两个重要方法-linkToDeath-unlinkTODeath"><a href="#Binder-的两个重要方法-linkToDeath-unlinkTODeath" class="headerlink" title="Binder 的两个重要方法 linkToDeath unlinkTODeath"></a>Binder 的两个重要方法 <code>linkToDeath</code> <code>unlinkTODeath</code></h3><blockquote><p>这两个方法用于监听 Binder 连接是否断裂。</p></blockquote><p>通过 linkToDeath 我们可以给 Binder 设置一个死亡代理，当 Binder 死亡时，我们就会收到通知。首先，我们声明一个 DeathRecipient 对象，其为接口，内部只有一个方法 binderDied，我们需要实现这个方法，当 Binder 死亡的时候，系统就会回调 binderDied 方法，然后我们就可以移除之前绑定的 binder 代理并重新绑定远程服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写在客户端中</span></span><br><span class="line"></span><br><span class="line">    IBookManager mBookManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mBookManager == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mBookManager.asBinder().unlinkToDeath(mDeathRecipient,<span class="number">0</span>);</span><br><span class="line">            mBookManager = <span class="keyword">null</span>;</span><br><span class="line">            bindService(<span class="keyword">new</span> Intent(<span class="string">"chen.easyview.aidl.IBookManager"</span>).setPackage(<span class="string">"chen.easyview"</span>)</span><br><span class="line">            ,conn, BIND_AUTO_CREATE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mBookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.linkToDeath(mDeathRecipient,<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另通过 Binder 的方法 isBinderAlive 也可以判断 Binder 是否死亡。</span></span><br></pre></td></tr></table></figure><blockquote><p>以上为 IPC 的基础知识，下篇将继续记录 Android 中的进程间通信</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记上篇&quot;&gt;&lt;a href=&quot;#本文为-《Android-开发艺术探索》-第二章-IPC机制-的笔记上篇&quot; class=&quot;headerlink&quot; title=&quot;本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记上篇&quot;&gt;&lt;/a&gt;本文为 《Android 开发艺术探索》 第二章-IPC机制 的笔记上篇&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="IPC" scheme="http://chennuo.online/categories/Android/IPC/"/>
    
    
      <category term="Android 开发艺术探索" scheme="http://chennuo.online/tags/Android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Activity四种启动模式</title>
    <link href="http://chennuo.online/2017/Android/Activity%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://chennuo.online/2017/Android/Activity四种启动模式/</id>
    <published>2017-12-29T03:06:31.000Z</published>
    <updated>2019-02-25T03:06:31.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在-Activity-的多-Activity-开发中，Activity-之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个-Activity-实例，而不是生成大量的重复的-Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个-Activity-实例。"><a href="#在-Activity-的多-Activity-开发中，Activity-之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个-Activity-实例，而不是生成大量的重复的-Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个-Activity-实例。" class="headerlink" title="在 Activity 的多 Activity 开发中，Activity 之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个 Activity 实例，而不是生成大量的重复的 Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个 Activity 实例。"></a>在 Activity 的多 Activity 开发中，Activity 之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个 Activity 实例，而不是生成大量的重复的 Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个 Activity 实例。</h4><p>在 Activity 里，有 4 种 Activity 的启动模式，分别为：</p><ul><li><p>standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。在这种模式下，activity默认会进入启动它的activity所属的任务栈中。注意：在非activity类型的context (如 ApplicationContext )并没有所谓的任务栈，所以不能通过ApplicationContext去启动standard模式的activity。</p></li><li><p>singleTop: 栈顶复用模式。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。注意：这个activity的onCreate，onStart，onResume不会被回调，因为他们并没有发生改变。</p></li><li><p>singleTask: 栈内复用模式。首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈。</p><ul><li>如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去。</li><li>如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例 。<ul><li>如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法。</li><li>如果不存在该实例，则新建Activity，并入栈</li></ul></li></ul></li></ul><ul><li>singleInstance: 这个跟singleTask基本上是一样，只有一个区别：这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</li></ul><a id="more"></a><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>standard：默认启动模式</p></li><li><p>singleTop: <strong>当且仅当启动的 Activity 和上一个 Activity 一致的时候才会通过调用<code>onNewIntent()</code>方法重用 Activity。</strong>使用场景：资讯阅读类 APP 的内容界面。</p></li><li><p>singleTask：浏览器的主页面，或者大部分 APP 的主页面。</p></li></ul><p>这些启动模式可以在功能清单文件AndroidManifest.xml中进行设置，中的launchMode属性。相关的代码中也有一些标志可以使用,比如我们想只启用一个实例,则可以使用 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 标志，这个标志表示：如果这个activity已经启动了，就不产生新的activity，而只是把这个activity实例加到栈顶来就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(ReorderFour.<span class="keyword">this</span>, ReorderTwo.class);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>Activity的加载模式受启动Activity的Intent对象中设置的Flag和manifest文件中Activity的元素的特性值交互控制。</p><p>下面是影响加载模式的一些特性。核心的Intent Flag有：</p><ul><li><p><code>FLAG_ACTIVITY_NEW_TASK</code></p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code></p></li><li><p><code>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</code></p></li><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code></p></li></ul><p>核心的特性有：</p><p>taskAffinity</p><p>launchMode</p><p>allowTaskReparenting</p><p>clearTaskOnLaunch</p><p>alwaysRetainTaskState</p><p>finishOnTaskLaunch</p><h3 id="四种加载模式的区别"><a href="#四种加载模式的区别" class="headerlink" title="四种加载模式的区别"></a>四种加载模式的区别</h3><ul><li>所属task的区别</li></ul><blockquote><p>一般情况下，standard 和 singleTop 的 activity 的目标task，和收到的 Intent 的发送者在同一个 task 内，就相当于谁调用它，它就跟谁在同一个Task中。除非Intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。singleTask 和 singleInstance 总是把要启动的 activity 作为一个 task 的根元素，他们不会被启动到一个其他 task 里。</p></blockquote><ul><li>是否允许多个实例</li></ul><blockquote><p>standard 和 singleTop 可以被实例化多次，并且是可以存在于不同的 task 中；这种实例化时一个 task 可以包括一个 activity 的多个实例；</p><p>singleTask 和 singleInstance 则限制只生成一个实例，并且是 task 的根元素。</p><p>singleTop 要求如果创建intent的时候栈顶已经有要创建的Activity的实例，则将intent发送给该实例，而不创建新的实例。</p></blockquote><ul><li>是否允许其它activity存在于本task内</li></ul><blockquote><p>singleInstance 独占一个 task，其它 activity 不能存在那个 task 里；如果它启动了一个新的 activity，不管新的 activity 的 launch mode 如何，新的 activity 都将会到别的 task 里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。</p></blockquote><p>而另外三种模式，则可以和其它activity共存。</p><ul><li>是否每次都生成新实例</li></ul><blockquote><p>standard 对于每一个启动 Intent 都会生成一个 activity 的新实例；</p><p>singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。比如：现在task栈元素为A - B - C - D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D</p><p>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。</p><p>singleInstance 是其所在栈的唯一activity，它会每次都被重用。</p><p>singleTask” 如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。 当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法，如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在-Activity-的多-Activity-开发中，Activity-之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个-Activity-实例，而不是生成大量的重复的-Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个-Activity-实例。&quot;&gt;&lt;a href=&quot;#在-Activity-的多-Activity-开发中，Activity-之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个-Activity-实例，而不是生成大量的重复的-Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个-Activity-实例。&quot; class=&quot;headerlink&quot; title=&quot;在 Activity 的多 Activity 开发中，Activity 之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个 Activity 实例，而不是生成大量的重复的 Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个 Activity 实例。&quot;&gt;&lt;/a&gt;在 Activity 的多 Activity 开发中，Activity 之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个 Activity 实例，而不是生成大量的重复的 Activity。加载模式便是决定以哪种方式启动一个跳转到原来某个 Activity 实例。&lt;/h4&gt;&lt;p&gt;在 Activity 里，有 4 种 Activity 的启动模式，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。在这种模式下，activity默认会进入启动它的activity所属的任务栈中。注意：在非activity类型的context (如 ApplicationContext )并没有所谓的任务栈，所以不能通过ApplicationContext去启动standard模式的activity。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;singleTop: 栈顶复用模式。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。注意：这个activity的onCreate，onStart，onResume不会被回调，因为他们并没有发生改变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;singleTask: 栈内复用模式。首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在，则会创建一个新的Task，并创建新的Activity实例入栈到新创建的Task中去。&lt;/li&gt;
&lt;li&gt;如果存在，则得到该任务栈，查找该任务栈中是否存在该Activity实例 。&lt;ul&gt;
&lt;li&gt;如果存在实例，则将它上面的Activity实例都出栈，然后回调启动的Activity实例的onNewIntent方法。&lt;/li&gt;
&lt;li&gt;如果不存在该实例，则新建Activity，并入栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;singleInstance: 这个跟singleTask基本上是一样，只有一个区别：这种模式下的Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="四大组件" scheme="http://chennuo.online/categories/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Activity 基本介绍</title>
    <link href="http://chennuo.online/2017/Android/Activity/"/>
    <id>http://chennuo.online/2017/Android/Activity/</id>
    <published>2017-12-29T03:00:45.000Z</published>
    <updated>2017-12-29T03:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内容包括"><a href="#内容包括" class="headerlink" title="内容包括"></a>内容包括</h3><ul><li>启动顺序</li><li>生命周期</li><li>三个时期</li><li>Activity 栈</li><li>Activity 状态</li><li>面试题</li></ul><a id="more"></a><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><ul><li>第一个Activity启动时：</li></ul><p>onCreate()——&gt;onStart()——&gt;onResume()</p><ul><li>当另一个Activity启动时:</li></ul><p>第一个Activity onPause()——&gt;第二个Activity onCreate()——&gt;onStart()——&gt;onResume()</p><p>——&gt;第一个Activity onStop()</p><ul><li>当返回到第一个Activity时：</li></ul><p>第二个Activity onPause() ——&gt; 第一个Activity　onRestart()——&gt;onStart()——&gt;onResume()</p><p>——&gt;第二个Activity onStop()——&gt;onDestroy()</p><h4 id="一个Activity的销毁顺序"><a href="#一个Activity的销毁顺序" class="headerlink" title="一个Activity的销毁顺序:"></a>一个Activity的销毁顺序:</h4><p>（情况一）onPause()——&gt;&lt;Process Killed&gt;</p><p>（情况二）onPause()——&gt;onStop()——&gt;&lt;Process Killed&gt;</p><p>（情况三）onPause()——&gt;onStop()——&gt;onDestroy()</p><p>但是当一个活动的状态发生改变的时候，开发者可以通过调用 onXX() 的方法获取到相关的通知信息。</p><p>在实现 Activity 类的时候，通过覆盖（ override ）这些方法即可在你需要处理的时候来调用。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li><strong>onCreate</strong> ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState （）方法保存的状态信息。</li><li><strong>onStart</strong> ：该方法的触发表示所属活动将被展现给用户。<strong>活动由不可见变为可见的时候调用</strong></li><li><strong>onResume</strong> ：当一个活动和用户发生交互的时候，触发该方法。<strong>此时的活动一定位于返回栈的栈顶，并且处于运行状态。</strong></li><li><strong>onPause</strong> ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。<strong>我们通常会在这个方法中将一些及其消耗 CPU 的资源释放掉（比如显示地图或者大规模图形），以及保存一些关键数据（比如用户输入的数据等等），但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</strong></li><li><strong>onStop</strong> ：当一个活动不再需要展示给用户的时候，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发 onStop 方法。 所以保存状态信息是应该在onPause时做，而不是onStop时做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。</li><li><strong>onRestart</strong> ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。</li><li><p><strong>onDestroy</strong> ：当活动销毁的时候，触发该方法。和 onStop 方法一样，如果内存紧张，系统会直接结束这个活动而不会触发该方法。</p></li><li><p><strong>onSaveInstanceState</strong>：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，已经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。</p></li></ol><h3 id="三个时期"><a href="#三个时期" class="headerlink" title="三个时期"></a>三个时期</h3><ul><li><p>完整生存期  </p></li><li><p>活动在<code>onCreate()</code>方法和<code>onDestroy()</code>方法之间所经历的，就是完整生存期。一般情况下，一个活动会在<code>onCreate()</code>方法中完成各种初始化操作，而在<code>onDestroy()</code>方法中完成释放内存的操作。</p></li><li><p>可见生存期<br><strong>划重点！！！这个问题我就在面试中遇到了，其实我知晓这个题，怎奈误解了面试官的意思答非所问了。</strong>活动在<code>onStart()</code>方法和<code>onStop()</code>方法之间所经历的，就是可见生存期。在可见生存期内， 活动对于用户总是可见的， 即便有可能无法和用户进行交互。 我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在<code>onStart()</code>方法中对资源进行加载，而在<code>onStop()</code>方法中对资源进行释放， 从而保证处于停止状态的活动不会占用过多内存。</p></li><li><p>前台生存期<br>活动在<code>onResume()</code>方法和<code>onPause()</code>方法之间所经历的，就是前台生存期。在前台生存期内， 活动总是处于运行状态的， 此时的活动是可以和用户进行相互的， 我们平时看到和接触最多的也这个状态下的活动。</p></li></ul><h3 id="Activity-栈"><a href="#Activity-栈" class="headerlink" title="Activity 栈"></a>Activity 栈</h3><p>上面提到开发者是无法控制Activity的状态的，那Activity的状态又是按照何种逻辑来运作的呢？这就要知道 Activity 栈。每个Activity的状态是由它在Activity栈（是一个后进先出LIFO，包含所有正在运行Activity的队列）中的位置决定的。当一个新的Activity启动时，当前的活动的Activity将会移到Activity栈的顶部。如果用户使用后退按钮返回的话，或者前台的Activity结束，活动的Activity就会被移出栈消亡，而在栈上的上一个活动的Activity将会移上来并变为活动状态。一个应用程序的优先级是受最高优先级的Activity影响的。当决定某个应用程序是否要终结去释放资源，Android内存管理使用栈来决定基于Activity的应用程序的优先级。</p><h3 id="Activity状态"><a href="#Activity状态" class="headerlink" title="Activity状态"></a>Activity状态</h3><p>一般认为Activity有以下四种状态：</p><ul><li><p>活动的：当一个Activity在栈顶，它是可视的、有焦点、可接受用户输入的。Android试图尽最大可能保持它活动状态，杀死其它Activity来确保当前活动Activity有足够的资源可使用。当另外一个Activity被激活，这个将会被暂停。</p></li><li><p>暂停：在很多情况下，你的Activity可视但是它没有焦点，换句话说它被暂停了。有可能原因是一个透明或者非全屏的Activity被激活。当被暂停，一个Activity仍会当成活动状态，只不过是不可以接受用户输入。在极特殊的情况下，Android将会杀死一个暂停的Activity来为活动的Activity提供充足的资源。当一个Activity变为完全隐藏，它将会变成停止。</p></li><li><p>停止：当一个Activity不是可视的，它“停止”了。这个Activity将仍然在内存中保存它所有的状态和会员信息。尽管如此，当其它地方需要内存时，它将是最有可能被释放资源的。当一个Activity停止后，一个很重要的步骤是要保存数据和当前UI状态。一旦一个Activity退出或关闭了，它将变为待用状态。</p></li><li><p>待用： 在一个Activity被杀死后和被装在前，它是待用状态的。待用Acitivity被移除Activity栈，并且需要在显示和可用之前重新启动它。</p></li></ul><h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><ul><li>Activity A 通过 Intent 显示启动了 Activity B，当 B 处于可见状态后，A 是否一定会调用<code>onStop()</code>?</li></ul><p>不一定，有可能A此时仍然可见，例如B是一个DialogActivity，或者其他A仍可见的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;内容包括&quot;&gt;&lt;a href=&quot;#内容包括&quot; class=&quot;headerlink&quot; title=&quot;内容包括&quot;&gt;&lt;/a&gt;内容包括&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;启动顺序&lt;/li&gt;
&lt;li&gt;生命周期&lt;/li&gt;
&lt;li&gt;三个时期&lt;/li&gt;
&lt;li&gt;Activity 栈&lt;/li&gt;
&lt;li&gt;Activity 状态&lt;/li&gt;
&lt;li&gt;面试题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="四大组件" scheme="http://chennuo.online/categories/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="四大组件" scheme="http://chennuo.online/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Server</title>
    <link href="http://chennuo.online/2017/Android/Server/"/>
    <id>http://chennuo.online/2017/Android/Server/</id>
    <published>2017-12-29T02:58:46.000Z</published>
    <updated>2017-12-29T02:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Service可以在和多场合的应用中使用，比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放，比如检测SD卡上文件的变化，再或者在后台记录你地理信息位置的改变等等，总之服务嘛，总是藏在后头的。</p><p>Service是在一段不定的时间运行在后台，不和用户交互应用组件。每个Service必须在manifest中 通过&lt;service&gt;来声明。可以通过contect.startservice和contect.bindserverice来启动。</p><p>Service和其他的应用组件一样，运行在进程的主线程中。这就是说如果service需要很多耗时或者阻塞的操作，需要在其子线程中实现。</p><a id="more"></a><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><h4 id="不论调用了多少次startService-方法，你只需要调用一次stopService-来停止服务。"><a href="#不论调用了多少次startService-方法，你只需要调用一次stopService-来停止服务。" class="headerlink" title="不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。"></a>不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。</h4><p><strong>使用context.startService() 启动Service时会经历:</strong></p><p>context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running</p><p>context.stopService() | -&gt;onDestroy() -&gt;Service stop</p><p>如果Service还没有运行，则android先调用onCreate()然后调用onStart()；如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</p><p>stopService的时候直接onDestroy，如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</p><p>所以调用startService的生命周期为：onCreate –&gt; onStart(可多次调用) –&gt; onDestroy</p><p><strong>特点：</strong><br>一旦服务开启就跟调用者（开启者）没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行，开启者不能调用服务里面的方法。</p><p><strong>使用context.bindService() 启动Service时会经历:</strong></p><p>context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running</p><p>onUnbind() -&gt; onDestroy() -&gt;Service stop</p><p>onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。这个时候把调用者（Context，例如Activity）会和Service绑定在一起，Context退出了，Srevice就会调用onUnbind-&gt;onDestroy相应退出。</p><p>所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</p><p>在Service每一次的开启关闭过程中，只有onStart可被多次调用(通过多次startService调用)，其他onCreate，onBind，onUnbind，onDestory在一个生命周期中只能被调用一次。</p><p><strong>特点：</strong><br>bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。</p><h3 id="service的两种模式（startService-bindService-不是完全分离的）"><a href="#service的两种模式（startService-bindService-不是完全分离的）" class="headerlink" title="service的两种模式（startService()/bindService()不是完全分离的）"></a>service的两种模式（startService()/bindService()不是完全分离的）</h3><h4 id="本地服务-Local-Service-用于应用程序内部。"><a href="#本地服务-Local-Service-用于应用程序内部。" class="headerlink" title="本地服务 Local Service 用于应用程序内部。"></a>本地服务 Local Service 用于应用程序内部。</h4><p>它可以启动并运行，直至有人停止了它或它自己停止。在这种方式下，它以调用Context.startService()启动，而以调用Context.stopService()结束。它可以调用Service.stopSelf() 或 Service.stopSelfResult()来自己停止。不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。用于实现应用程序自己的一些耗时任务，比如查询升级信息，并不占用应用程序比如Activity所属线程，而是单开线程后台执行，这样用户体验比较好。</p><blockquote><p>调用者和service在同一个进程里，所以运行在主进程的main线程中。所以不能进行耗时操作，可以采用在service里面创建一个Thread来执行任务。service影响的是进程的生命周期，讨论与Thread的区别没有意义。<br>任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service的实例。</p></blockquote><h4 id="远程服务-Remote-Service-用于android系统内部的应用程序之间。"><a href="#远程服务-Remote-Service-用于android系统内部的应用程序之间。" class="headerlink" title="远程服务 Remote Service 用于android系统内部的应用程序之间。"></a>远程服务 Remote Service 用于android系统内部的应用程序之间。</h4><p>它可以通过自己定义并暴露出来的接口进行程序操作。客户端建立一个到服务对象的连接，并通过那个连接来调用服务。连接以调用Context.bindService()方法建立，以调用 Context.unbindService()关闭。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。可被其他应用程序复用，比如天气预报服务，其他应用程序不需要再写这样的服务，调用已有的即可。</p><blockquote><p>调用者和service不在同一个进程中，service在单独的进程中的main线程，是一种垮进程通信方式</p></blockquote><h4 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h4><p>IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题：</p><ul><li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；</li><li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；</li></ul><p>IntentService特征:</p><ul><li>会创建独立的worker线程来处理所有的Intent请求；</li><li>会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题；</li><li>所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service；</li><li>为Service的onBind()提供默认实现，返回null；</li><li>为Service的onStartCommand提供默认实现，将请求Intent添加到队列中；</li></ul><p>参考资料：<br><a href="https://www.jianshu.com/p/51aaa65d5d25" target="_blank" rel="noopener">https://www.jianshu.com/p/51aaa65d5d25</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service可以在和多场合的应用中使用，比如播放多媒体的时候用户启动了其他Activity这个时候程序要在后台继续播放，比如检测SD卡上文件的变化，再或者在后台记录你地理信息位置的改变等等，总之服务嘛，总是藏在后头的。&lt;/p&gt;
&lt;p&gt;Service是在一段不定的时间运行在后台，不和用户交互应用组件。每个Service必须在manifest中 通过&amp;lt;service&amp;gt;来声明。可以通过contect.startservice和contect.bindserverice来启动。&lt;/p&gt;
&lt;p&gt;Service和其他的应用组件一样，运行在进程的主线程中。这就是说如果service需要很多耗时或者阻塞的操作，需要在其子线程中实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="四大组件" scheme="http://chennuo.online/categories/Android/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Permission</title>
    <link href="http://chennuo.online/2017/Android/Permission/"/>
    <id>http://chennuo.online/2017/Android/Permission/</id>
    <published>2017-12-29T02:47:24.000Z</published>
    <updated>2017-12-29T02:47:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-0-动态权限申请，自己封装使用的一个-Activity"><a href="#6-0-动态权限申请，自己封装使用的一个-Activity" class="headerlink" title="6.0 动态权限申请，自己封装使用的一个 Activity"></a>6.0 动态权限申请，自己封装使用的一个 Activity</h1><a id="more"></a><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ul><li>Activity 设置透明背景</li><li><code>android:theme=&quot;@android:style/Theme.Translucent.NoTitleBar&quot;</code></li><li>暂时仅设置每次申请一种权限</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.M) &#123;</span><br><span class="line">        PermissionActivity.startNewActivity(context, Manifest.permission.WRITE_EXTERNAL_STORAGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Activity-源码"><a href="#Activity-源码" class="headerlink" title="Activity 源码"></a>Activity 源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSION = <span class="string">"PERMISSION"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_Code = <span class="number">2017</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_permission);</span><br><span class="line">        isImmersive = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            setTranslucentStatus(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为状态栏着色</span></span><br><span class="line">        SystemBarTintManager tintManager = <span class="keyword">new</span> SystemBarTintManager(<span class="keyword">this</span>);</span><br><span class="line">        tintManager.setStatusBarTintEnabled(<span class="keyword">true</span>);</span><br><span class="line">        tintManager.setStatusBarTintColor(Color.TRANSPARENT);</span><br><span class="line"></span><br><span class="line">        KLog.e(Build.FINGERPRINT);</span><br><span class="line">        findViewById(R.id.background).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String mPermission = getIntent().getStringExtra(PERMISSION);</span><br><span class="line">        <span class="keyword">if</span> (!TextUtil.isValidate(mPermission))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        checkPermission(mPermission, REQUEST_Code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (PermissionChecker.checkSelfPermission(PermissionActivity.<span class="keyword">this</span>, permission)) &#123;</span><br><span class="line">            <span class="keyword">case</span> PermissionChecker.PERMISSION_GRANTED:</span><br><span class="line">                KLog.e(permission + <span class="string">" 已申请"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (permission) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Manifest.permission.ACCESS_COARSE_LOCATION:</span><br><span class="line">                        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<span class="comment">//这个需要版本号大于19</span></span><br><span class="line">                            AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">                            <span class="keyword">int</span> checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_COARSE_LOCATION, android.os.Process.myUid(), getPackageName());</span><br><span class="line"></span><br><span class="line">                            checkAppOpsManager(permission, checkOp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Manifest.permission.ACCESS_FINE_LOCATION:</span><br><span class="line">                        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<span class="comment">//这个需要版本号大于19</span></span><br><span class="line">                            AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">                            <span class="keyword">int</span> checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_FINE_LOCATION, android.os.Process.myUid(), getPackageName());</span><br><span class="line"></span><br><span class="line">                            checkAppOpsManager(permission, checkOp);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Manifest.permission.READ_CONTACTS:</span><br><span class="line">                        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;<span class="comment">//这个需要版本号大于19</span></span><br><span class="line"></span><br><span class="line">                            AppOpsManager appOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                                <span class="keyword">int</span> checkOp = appOpsManager.checkOp(AppOpsManager.OPSTR_READ_CONTACTS, android.os.Process.myUid(), getPackageName());</span><br><span class="line"></span><br><span class="line">                                checkAppOpsManager(permission, checkOp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                checkAppOpsManagerCompat(permission);</span><br><span class="line"></span><br><span class="line">                finish();</span><br><span class="line"><span class="comment">//            Intent intent = new Intent("android.content.pm.action.REQUEST_PERMISSIONS");</span></span><br><span class="line"><span class="comment">//            intent.putExtra("android.content.pm.extra.REQUEST_PERMISSIONS_NAMES", permission);</span></span><br><span class="line"><span class="comment">//            startActivity(intent);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PermissionChecker.PERMISSION_DENIED:</span><br><span class="line">                checkShowRequestPermissionRationale(<span class="string">"未申请"</span>, permission, requestCode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PermissionChecker.PERMISSION_DENIED_APP_OP:</span><br><span class="line">                checkShowRequestPermissionRationale(<span class="string">"APP_OP未申请"</span>, permission, requestCode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                KLog.e(PermissionChecker.checkSelfPermission(PermissionActivity.<span class="keyword">this</span>, permission));</span><br><span class="line"></span><br><span class="line">                checkShowRequestPermissionRationale(<span class="string">"error"</span>, permission, requestCode);</span><br><span class="line"></span><br><span class="line">                ActivityCompat.requestPermissions(PermissionActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;permission&#125;, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkShowRequestPermissionRationale</span><span class="params">(String starte, <span class="keyword">final</span> String permission, <span class="keyword">final</span> <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">        KLog.e(permission + <span class="string">":"</span> + starte);</span><br><span class="line">        <span class="keyword">if</span> (shouldShowRequestPermissionRationale(PermissionActivity.<span class="keyword">this</span>, permission)) &#123;</span><br><span class="line">            KLog.e(starte + <span class="string">":自定义弹窗"</span>);</span><br><span class="line">            Dialogbox_permission.newInstance(PermissionActivity.<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(<span class="string">"获取权限"</span>)</span><br><span class="line">                    .setContent(getString(permission))</span><br><span class="line">                    .setCancel(<span class="string">"残忍拒绝"</span>)</span><br><span class="line">                    .setOk(<span class="string">"重新授权"</span>)</span><br><span class="line">                    .setOnCallback(</span><br><span class="line">                            <span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                                    ActivityCompat.requestPermissions(PermissionActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;permission&#125;, requestCode);</span><br><span class="line">                                    dialogObject.dialog.cancel();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                    )</span><br><span class="line">                    .setCancelOnCallback(<span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                            finish();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KLog.e(starte + <span class="string">":开始请求"</span>);</span><br><span class="line">            ActivityCompat.requestPermissions(PermissionActivity.<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;permission&#125;, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkAppOpsManagerCompat(permission);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAppOpsManager</span><span class="params">(String permission, <span class="keyword">int</span> checkOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (checkOp) &#123;</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_ALLOWED:</span><br><span class="line">                KLog.e(permission + <span class="string">" MODE_ALLOWED"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_DEFAULT:</span><br><span class="line">                KLog.e(permission + <span class="string">" MODE_DEFAULT"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_ERRORED:</span><br><span class="line">                KLog.e(permission + <span class="string">" MODE_ERRORED"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_IGNORED:</span><br><span class="line">                KLog.e(permission + <span class="string">" MODE_IGNORED"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                KLog.e(permission + <span class="string">" MODE_DEFAULT: "</span> + checkOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkAppOpsManagerCompat</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line">        String permissionToOp = AppOpsManagerCompat.permissionToOp(permission);</span><br><span class="line">        <span class="keyword">if</span> (permissionToOp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            KLog.e(permission + <span class="string">" permissionToOp 为 null 仍需要授权？需要 SDK &gt;= 23"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KLog.e(permission + <span class="string">" permissionToOp 为 "</span> + permissionToOp);</span><br><span class="line">            <span class="keyword">int</span> noteOp = AppOpsManagerCompat.noteOp(PermissionActivity.<span class="keyword">this</span>, permissionToOp, android.os.Process.myUid(), getBaseContext().getPackageName());</span><br><span class="line">            <span class="keyword">switch</span> (noteOp) &#123;</span><br><span class="line">                <span class="keyword">case</span> AppOpsManagerCompat.MODE_ALLOWED:</span><br><span class="line">                    KLog.e(permission + <span class="string">" AppOpsManagerCompat.MODE_ALLOWED"</span>);</span><br><span class="line">                    KLog.e(<span class="string">"-----------------------"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AppOpsManagerCompat.MODE_DEFAULT:</span><br><span class="line">                    KLog.e(permission + <span class="string">" AppOpsManagerCompat.MODE_DEFAULT"</span>);</span><br><span class="line">                    KLog.e(<span class="string">"xxxxxxxxxxxxxxxxxxxxxxx"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AppOpsManagerCompat.MODE_IGNORED:</span><br><span class="line">                    KLog.e(<span class="string">"iiiiiiiiiiiiiiiiiiiiiii"</span>);</span><br><span class="line">                    KLog.e(permission + <span class="string">" AppOpsManagerCompat.MODE_IGNORED"</span>);<span class="comment">//小米在系统取消授权后，会调到这里，请求的回调都是成功，然而事实不是，考虑跳通知界面</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    KLog.e(permission + <span class="string">" AppOpsManagerCompat.MODE "</span> + noteOp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> requestCode, @NonNull <span class="keyword">final</span> String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (permissions == <span class="keyword">null</span> || permissions.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        KLog.e(<span class="string">"onRequestPermissionsResult:"</span> + permissions[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_Code:</span><br><span class="line">                <span class="keyword">if</span> (verifyPermissions(grantResults)) &#123;</span><br><span class="line">                    KLog.e(Arrays.toString(permissions) + <span class="string">" 申请成功"</span>);</span><br><span class="line">                    finish();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (PermissionActivity.shouldShowRequestPermissionRationale(PermissionActivity.<span class="keyword">this</span>, permissions)) &#123;</span><br><span class="line"></span><br><span class="line">                        Dialogbox_permission.newInstance(PermissionActivity.<span class="keyword">this</span>)</span><br><span class="line">                                .setTitle(<span class="string">"获取权限"</span>)</span><br><span class="line">                                .setContent(getString(permissions[<span class="number">0</span>]))</span><br><span class="line">                                .setCancel(<span class="string">"残忍拒绝"</span>)</span><br><span class="line">                                .setOk(<span class="string">"重新授权"</span>)</span><br><span class="line">                                .setOnCallback(<span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                                        ActivityCompat.requestPermissions(PermissionActivity.<span class="keyword">this</span>, permissions, requestCode);</span><br><span class="line">                                        dialogObject.dialog.cancel();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .setCancelOnCallback(<span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                                        finish();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;).show();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        Dialogbox_permission.newInstance(PermissionActivity.<span class="keyword">this</span>)</span><br><span class="line">                                .setTitle(<span class="string">"获取权限"</span>)</span><br><span class="line">                                .setContent(getString2(permissions[<span class="number">0</span>]))</span><br><span class="line">                                .setCancel(<span class="string">"我已了解"</span>)</span><br><span class="line">                                .setOk(<span class="string">"前往设置"</span>)</span><br><span class="line">                                .setOnCallback(<span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                                        startActivity(PermissionsPageManager.getIntent(PermissionActivity.<span class="keyword">this</span>));</span><br><span class="line">                                        dialogObject.dialog.cancel();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .setCancelOnCallback(<span class="keyword">new</span> Dialogbox_permission.OnCallback() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Dialogbox_permission.DialogObject dialogObject)</span> </span>&#123;</span><br><span class="line">                                        finish();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .show();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyPermissions</span><span class="params">(<span class="keyword">int</span>... grantResults)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grantResults.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> result : grantResults) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks given permissions are needed to show rationale.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> activity    activity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permissions permission list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> returns true if one of the permission is needed to show rationale.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(Activity activity, String... permissions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String permission : permissions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks given permissions are needed to show rationale.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment    fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permissions permission list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> returns true if one of the permission is needed to show rationale.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldShowRequestPermissionRationale</span><span class="params">(android.support.v4.app.Fragment fragment, String... permissions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String permission : permissions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fragment.shouldShowRequestPermissionRationale(permission)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Spanned <span class="title">getString</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtil.isValidate(permission)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Html.fromHtml(<span class="string">"完善App功能需要该权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (permission) &#123;</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.ACCESS_COARSE_LOCATION:</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.ACCESS_FINE_LOCATION:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;位置信息&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.CAMERA:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;相机&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.WRITE_EXTERNAL_STORAGE:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;SD卡&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常更新或使用XXX应用"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.READ_PHONE_STATE:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;读取设备信息&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常更新或使用XXX应用"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.READ_CONTACTS:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;读取联系人&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.RECORD_AUDIO:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"我们需要获取&lt;font color='#0378d8'&gt;麦克风&lt;/font&gt;权限，以便为您提供相应服务。否则您将无法正常使用该功能"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"完善App功能需要该权限"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Spanned <span class="title">getString2</span><span class="params">(String permission)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtil.isValidate(permission)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Html.fromHtml(<span class="string">"权限缺少将对体验造成较大影响"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (permission) &#123;</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.ACCESS_COARSE_LOCATION:</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.ACCESS_FINE_LOCATION:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;位置信息&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.CAMERA:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;相机&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.WRITE_EXTERNAL_STORAGE:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;SD卡&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.READ_PHONE_STATE:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;读取设备信息&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.READ_CONTACTS:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;读取联系人&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">case</span> Manifest.permission.RECORD_AUDIO:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"由于无法获取&lt;font color='#0378d8'&gt;麦克风&lt;/font&gt;权限，请手动开启该该权限，以便获取更好的体验&lt;br&gt;&lt;br&gt;设置路径：系统设置-&gt;XXX应用-&gt;权限"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> Html.fromHtml(<span class="string">"权限缺少将对体验造成较大影响"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startNewActivity</span><span class="params">(Context context, String permission)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(context, PermissionActivity.class);</span><br><span class="line">        intent.putExtra(PERMISSION, permission);</span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;6-0-动态权限申请，自己封装使用的一个-Activity&quot;&gt;&lt;a href=&quot;#6-0-动态权限申请，自己封装使用的一个-Activity&quot; class=&quot;headerlink&quot; title=&quot;6.0 动态权限申请，自己封装使用的一个 Activity&quot;&gt;&lt;/a&gt;6.0 动态权限申请，自己封装使用的一个 Activity&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
      <category term="新特性" scheme="http://chennuo.online/categories/Android/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Android冷知识</title>
    <link href="http://chennuo.online/2017/Android/Android%E5%86%B7%E7%9F%A5%E8%AF%86/"/>
    <id>http://chennuo.online/2017/Android/Android冷知识/</id>
    <published>2017-12-29T02:44:17.000Z</published>
    <updated>2017-12-29T02:44:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录一些在面试题中可能出现的冷知识"><a href="#记录一些在面试题中可能出现的冷知识" class="headerlink" title="记录一些在面试题中可能出现的冷知识"></a>记录一些在面试题中可能出现的冷知识</h1><p>持续更新</p><a id="more"></a><p>1、 Android应用的所有UI组件都继承了View类，View类还有一个重要的子类：VIewGroup，但ViewGroup通常作为其他组件的容器使用。</p><p>2、 ListView、GridView、Spinner、Gallery等AdapterView都只是容器，而Adapter负责提供每个“列表项”组件，AdapterView则负责采用合适的方式显示这些列表项。</p><p>3、 Android已经不推荐使用Gallery组件，推荐使用其他水平滚动组件HorizontalSorollView和ViewPager</p><p>4、 Android系统包含两套事件处理系统</p><ul><li>基于监听的事件处理</li></ul><p>沿袭Java方式有：</p><blockquote><p>内部类形式：将事件监听器类定义成当前类的内部类</p><p>外部类形式：将事件监听器类定义成一个外部类</p><p>Activity本身作为事件监听器类：让Activity本身实现监听器接口，并实现事件处理方法</p><p>匿名内部类形式：使用匿名内部类创建事件监听器对象</p></blockquote><p>Android方式有：</p><blockquote><p>直接绑定到android界面组件标签</p></blockquote><ul><li>基于回调的事件处理</li></ul><p>重写View控件，对回调函数进行处理</p><ul><li>基于回调的事件传播</li></ul><p>如果处理事情的回调方法返回true，则表明改处理方法已完全处理该事件，该事件不会传播出去。反之false则会继续传播下去</p><p><strong>Button组件实践：</strong>Android系统最先触发的是Button上绑定的事件监听器，接着才触发该组件提供的事件的回调方法，然后还会传播到该组件所在的Activity。</p><p><strong>顺序</strong>：事件监听器—&gt;组件回调方法—&gt; Activity</p><p>对比Android提供的两种事件处理模型，不难发现基于监听的事件处理模型具有更大的优势：</p><ul><li>基于监听的事件模型分工更明确，事件源、事件监听由两个类分开实现，因此具有更好的可维护性。</li><li>Android的事件处理机制保证基于监听的事件监听器会被优先触发。</li></ul><p>5、 Android的UI操作并不是线程安全的。故Android制定了一条简单的规则：只允许UI线程修改Activity里的UI组件。Android不允许在新的线程中访问Activity里面的界面组件。</p><p>6、若应用程序没有声明任何一个活动作为主活动，这个程序仍然可以正常安装。只是你无法在启动器中看到或者打开这个程序。这种程序一般作为第三方服务供其他应用在内部进行调用的，如支付宝快捷支付服务。</p><p>7、 在Manifest中对Activity进行theme定义，可将activity显示模式变成对话框形式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">android:name</span>=<span class="string">".xxxx"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.Dialog"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>8、res/raw和assets</p><ul><li>相同点</li></ul><blockquote><p>两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。</p></blockquote><ul><li>不同点</li></ul><blockquote><p>res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；</p><p>assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。</p><p>res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹</p></blockquote><ul><li>读取文件资源</li></ul><p>读取res/raw下的文件资源，通过以下方式获取输入流来进行写操作</p><p><code>InputStream is =getResources().openRawResource(R.id.filename);</code></p><p>读取assets下的文件资源，通过以下方式获取输入流来进行写操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetManager am = <span class="keyword">null</span>;</span><br><span class="line">am = getAssets();</span><br><span class="line">InputStream is = am.open(<span class="string">"filename"</span>);</span><br></pre></td></tr></table></figure><ul><li>注</li></ul><blockquote><p>1：Google的Android系统处理Assert有个bug，在AssertManager中不能处理单个超过1MB的文件，不然会报异常，raw没这个限制可以放个4MB的Mp3文件没问题。</p><p>2：assets 文件夹是存放不进行编译加工的原生文件，即该文件夹里面的文件不会像 xml， java 文件被预编译，可以存放一些图片，html，js, css 等文件。</p></blockquote><p>9、 Mipmap图像</p><p>APK分包时，mipmap资源会全部包含在APK文件中，所以Android推荐将启动器图标放进mipmap目录中</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;记录一些在面试题中可能出现的冷知识&quot;&gt;&lt;a href=&quot;#记录一些在面试题中可能出现的冷知识&quot; class=&quot;headerlink&quot; title=&quot;记录一些在面试题中可能出现的冷知识&quot;&gt;&lt;/a&gt;记录一些在面试题中可能出现的冷知识&lt;/h1&gt;&lt;p&gt;持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android开发小技巧</title>
    <link href="http://chennuo.online/2017/Android/Android%E5%BC%80%E5%8F%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://chennuo.online/2017/Android/Android开发小技巧/</id>
    <published>2017-12-29T02:42:26.000Z</published>
    <updated>2017-12-29T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些在工作中会遇到的好方法"><a href="#一些在工作中会遇到的好方法" class="headerlink" title="一些在工作中会遇到的好方法"></a>一些在工作中会遇到的好方法</h1><a id="more"></a><h3 id="知晓当前在哪个活动之中"><a href="#知晓当前在哪个活动之中" class="headerlink" title="知晓当前在哪个活动之中"></a>知晓当前在哪个活动之中</h3><p>新建一个BaseActivity ，在OnCreate中加上</p><p>Log.e(“BaseActivity”, getClass().getSimpleName());</p><h3 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a><del>随时随地退出程序</del></h3><p><del>新建一个ActivityCollector类作为活动的管理器</del></p><p><del>在Activity管理器中维护一个activity的列表，用于activity新建和销毁的记录，实现add和remove两个方法，并实现finishALl方法。</del></p><p><del>在BaseActivity的onCreated()中</del></p><p><del>ActivityCollector.add(this)</del></p><p><del>在onDestroy()中</del></p><p><del>ActivityCollector.remove(this)</del></p><p><del>在任意Activity中想退出程序都可以调用ActivityCollector.finishAll()</del></p><p>不够优雅，改为监听生命周期的方式 ActivityLifecycleCallbacks</p><h3 id="启动活动的最佳写法"><a href="#启动活动的最佳写法" class="headerlink" title="启动活动的最佳写法"></a>启动活动的最佳写法</h3><p>在目标SecondActivity中写下如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">activityStart</span><span class="params">(Context context, String data1, String data2,……)</span></span>&#123;</span><br><span class="line">     Intent intent = <span class="keyword">new</span> Intent(context , SecondActivity.class);</span><br><span class="line">     intent.putExtra(<span class="string">"param1"</span>, data1);</span><br><span class="line">     intent.putExtra(<span class="string">"param2"</span>, data2);</span><br><span class="line">     context.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首FirstActivity中就可以通过 SecondActivity.activityStart(FirstActivity.this, “xxx” ,”xxx” );</p><p>完成启动的写法。这样利于多人协作，调用其他人写的Activity时不用考虑传参细节。</p><h3 id="Android-向上回退操作"><a href="#Android-向上回退操作" class="headerlink" title="Android 向上回退操作"></a>Android 向上回退操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,xxx,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">startActivity(intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一些在工作中会遇到的好方法&quot;&gt;&lt;a href=&quot;#一些在工作中会遇到的好方法&quot; class=&quot;headerlink&quot; title=&quot;一些在工作中会遇到的好方法&quot;&gt;&lt;/a&gt;一些在工作中会遇到的好方法&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>文字混排</title>
    <link href="http://chennuo.online/2017/Android/%E6%96%87%E5%AD%97%E6%B7%B7%E6%8E%92/"/>
    <id>http://chennuo.online/2017/Android/文字混排/</id>
    <published>2017-12-29T02:39:38.000Z</published>
    <updated>2017-12-29T02:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="ALinaCenterImageSpan"><a href="#ALinaCenterImageSpan" class="headerlink" title="ALinaCenterImageSpan"></a>ALinaCenterImageSpan</h3><p>在使用过程中，发现当ImageSpan设置基线对齐时，因为TextView设置了行间距例如android:lineSpacingExtra=”5dp”在6.0以下无法正常显示，故重写ImageSpan重新设置ImageSpan居中</p><p><a href="http://www.jianshu.com/p/add321678859" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlignCenterImageSpan</span> <span class="keyword">extends</span> <span class="title">ImageSpan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlignCenterImageSpan</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Paint.FontMetricsInt fm = paint.getFontMetricsInt();</span><br><span class="line">        Drawable b = getDrawable();</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="keyword">int</span> transY = (y + fm.descent + y + fm.ascent) / <span class="number">2</span> - b.getBounds().bottom / <span class="number">2</span>;<span class="comment">//计算y方向的位移</span></span><br><span class="line">        canvas.translate(x, transY);</span><br><span class="line">        b.draw(canvas);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法为 移动 图片位置的计算，目前看不懂</p><p>另，如果需要对图片添加点击事件，简单处理可以在相同位置添加 ClickSpan ，而且记得要对 TextView 的点击事件进行处理，配置如下方法</p><blockquote><p>mTextView.setMovementMethod(LinkMovementMethod.getInstance());//解决点击冲突</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;ALinaCenterImageSpan&quot;&gt;&lt;a href=&quot;#ALinaCenterImageSpan&quot; class=&quot;headerlink&quot; title=&quot;ALinaCenterImageSpan&quot;&gt;&lt;/a&gt;ALinaCen
      
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>ViewPager + Fragment</title>
    <link href="http://chennuo.online/2017/Android/ViewPagerAndFragment/"/>
    <id>http://chennuo.online/2017/Android/ViewPagerAndFragment/</id>
    <published>2017-12-29T02:33:25.000Z</published>
    <updated>2017-12-29T02:33:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ViewPager-里对-Fragment-的相关优化操作"><a href="#ViewPager-里对-Fragment-的相关优化操作" class="headerlink" title="ViewPager 里对 Fragment 的相关优化操作"></a>ViewPager 里对 Fragment 的相关优化操作</h1><h1 id="FragmentPagerAdapter-和-FragmentStatePagerAdapter-的区别"><a href="#FragmentPagerAdapter-和-FragmentStatePagerAdapter-的区别" class="headerlink" title="FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别"></a>FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别</h1><p><a href="https://mp.weixin.qq.com/s/gG4BJHtb0fQcM5um_lubVg" target="_blank" rel="noopener">参考链接</a></p><a id="more"></a><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>ViewPager是support v4库中提供界面滑动的类，继承自ViewGroup。PagerAdapter是ViewPager的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用PagerAdapter的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter作为ViewPager的适配器，他们的特点是界面是Fragment。</p><blockquote><p>在support v13和support v4中都提供了FragmentPagerAdapter和FragmentStatePagerAdapter，区别在于：support v13中使用android.app.Fragment，而support v4使用android.support.v4.app.Fragment。一般都使用support v4中的FragmentPagerAdapter和FragmentStatePagerAdapter。</p></blockquote><p>默认，ViewPager会缓存当前页相邻的界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即Fragment对象，且生命周期函数运行到onResume()），可以通过<strong>setOffscreenPageLimit(count)</strong>设置离线缓存的界面个数。</p><p>FragmentPagerAdapter和FragmentStatePagerAdapter需要重写的方法都一样，常见的重写方法如下：</p><ul><li><p><code>public FragmentPagerAdapter(FragmentManager fm)</code>: 构造函数，参数为FragmentManager。如果是嵌套Fragment场景，子PagerAdapter的参数传入getChildFragmentManager()。</p></li><li><p><code>Fragment getItem(int position)</code>: 返回第position位置的Fragment，必须重写。</p></li><li><p><code>int getCount()</code>: 返回ViewPager的页数，必须重写。</p></li><li><p><code>Object instantiateItem(ViewGroup container, int position)</code>: container是ViewPager对象，返回第position位置的Fragment。</p></li><li><p><code>void destroyItem(ViewGroup container, int position, Object object)</code>: container是ViewPager对象，object是Fragment对象。</p></li><li><p><code>getItemPosition(Object object)</code>: object是Fragment对象，如果返回POSITION_UNCHANGED，则表示当前Fragment不刷新，如果返回POSITION_NONE，则表示当前Fragment需要调用<code>destroyItem()</code>和<code>instantiateItem()</code>进行销毁和重建。 默认情况下返回POSITION_UNCHANGED。</p></li></ul><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>懒加载主要用于ViewPager且每页是Fragment的情况，场景为微信主界面，底部有4个tab，当滑到另一个tab时，先显示”正在加载”，过一会才会显示正常界面。</p><p>默认情况，ViewPager会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。</p><p>这里懒加载的实现思路是：用户不可见的界面，只初始化UI，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。</p><p>这里就实现类似微信那种效果，整个UI布局为：底部用PagerBottomTabStrip项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。</p><p>ViewPager默认缓存左右相邻界面，为了避免不必要的重新数据加载（重复调用<code>onCreateView()</code>），因为有4个tab，因此将离线缓存的半径设置为3，即<code>setOffscreenPageLimit(3)</code>。</p><p>懒加载主要依赖Fragment的<code>setUserVisibleHint(boolean isVisible)</code>方法，当Fragment变为可见时，会调用<code>setUserVisibleHint(true)</code>；当Fragment变为不可见时，会调用<code>setUserVisibleHint(false)</code>，且该方法调用时机：</p><ul><li><p><code>onAttach()</code>之前，调用<code>setUserVisibleHint(false)</code>。</p></li><li><p><code>onCreateView()</code>之前，如果该界面为当前页，则调用<code>setUserVisibleHint(true)</code>，否则调用<code>setUserVisibleHint(false)</code>。</p></li><li><p>界面变为可见时，调用<code>setUserVisibleHint(true)</code>。</p></li><li><p>界面变为不可见时，调用<code>setUserVisibleHint(false)</code>。</p></li></ul><p>懒加载Fragment的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseLazyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Context mContext;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> isInit;<span class="comment">//loadLazyData 之后要设为 true ,防止重复加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsPrepared;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(context);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">                             @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreateView(inflater, container, savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (getArguments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getFragmentArguments(getArguments());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(getContentView(), container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCreated</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        initView(view, savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        mIsPrepared = <span class="keyword">true</span>;</span><br><span class="line">        lazyLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserVisibleHint</span><span class="params">(<span class="keyword">boolean</span> isVisibleToUser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        <span class="keyword">if</span> (isVisibleToUser) &#123;</span><br><span class="line">            lazyLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lazyLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !isInit) &#123;</span><br><span class="line">            <span class="comment">//异步初始化</span></span><br><span class="line">            loadLazyData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getFragmentArguments</span><span class="params">(Bundle args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LayoutRes</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getContentView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(View view, @Nullable Bundle savedInstanceState)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadLazyData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        ShowUtils.showToast(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示是否正在加载中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">(<span class="keyword">boolean</span> toggle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toggle) &#123;</span><br><span class="line">            ShowUtils.showProgressDialog(mContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ShowUtils.dismissProgressDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><p>在Fragment中有两个变量控制是否需要做数据加载：</p><ul><li>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为<code>setUserVisibleHint()</code>会在<code>onCreateView()</code>之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。</li><li>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为<code>setUserVisibleHint(true)</code>在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用<code>setUserVisibleHint(true)</code>，此时由于mIsInited=true，因此不会再做一遍数据加载。</li></ul></li><li><p>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调<code>loadData()</code>做数据加载，数据加载做完后把mIsInited置为true。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ViewPager-里对-Fragment-的相关优化操作&quot;&gt;&lt;a href=&quot;#ViewPager-里对-Fragment-的相关优化操作&quot; class=&quot;headerlink&quot; title=&quot;ViewPager 里对 Fragment 的相关优化操作&quot;&gt;&lt;/a&gt;ViewPager 里对 Fragment 的相关优化操作&lt;/h1&gt;&lt;h1 id=&quot;FragmentPagerAdapter-和-FragmentStatePagerAdapter-的区别&quot;&gt;&lt;a href=&quot;#FragmentPagerAdapter-和-FragmentStatePagerAdapter-的区别&quot; class=&quot;headerlink&quot; title=&quot;FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别&quot;&gt;&lt;/a&gt;FragmentPagerAdapter 和 FragmentStatePagerAdapter 的区别&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gG4BJHtb0fQcM5um_lubVg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Intent</title>
    <link href="http://chennuo.online/2017/Android/Intent/"/>
    <id>http://chennuo.online/2017/Android/Intent/</id>
    <published>2017-12-29T02:27:14.000Z</published>
    <updated>2017-12-29T02:27:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍-Intent-的一些特殊使用（未完待续）"><a href="#介绍-Intent-的一些特殊使用（未完待续）" class="headerlink" title="介绍 Intent 的一些特殊使用（未完待续）"></a>介绍 Intent 的一些特殊使用（未完待续）</h1><a id="more"></a><h3 id="1、-lt-intent-filter-gt-与Action和Category项（动作和附加类别信息）"><a href="#1、-lt-intent-filter-gt-与Action和Category项（动作和附加类别信息）" class="headerlink" title="1、&lt;intent-filter&gt;与Action和Category项（动作和附加类别信息）"></a>1、&lt;intent-filter&gt;与Action和Category项（动作和附加类别信息）</h3><p>例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一个Intent对象最多只能包含一个Action属性，通过setAction()来设置属性值；</p><p>一个Intent对象可以包含多个Category属性，通过addCategory()来添加Category属性</p><p>但是在AndroidManifest.xml中，Activity里的&lt;intent-filter&gt;可以有多个Action属性和Category属性</p></blockquote><p>当Intent被创建时，该Intent默认启动Category属性值为<code>Intent.CATEGORY_DEFAULT</code>属性（常量值为<code>android.intent.category.DEFAULT</code>）的组件。</p><p>实际上，Android内部提供了大量标准Action、Catetory常量。（电话、短信、web）</p><h3 id="2、-lt-intent-filter-gt-与Data和Type项"><a href="#2、-lt-intent-filter-gt-与Data和Type项" class="headerlink" title="2、&lt;intent-filter&gt;与Data和Type项"></a>2、&lt;intent-filter&gt;与Data和Type项</h3><p>Data属性通常用于向Action属性提供操作的数据。Data数据接受一个Uri对象。</p><p>Type属性用于指定该Data所指定Uri对应的MIME类型（可为任意自定义类型，须符合abc/xyz格式即可）</p><p>注：</p><blockquote><p>两属性直接存在相互覆盖的情况（按设置顺序，后者覆盖前者），若要两者同时存在，则使用setDataAndType()方法。</p></blockquote><h3 id="3、Extra属性"><a href="#3、Extra属性" class="headerlink" title="3、Extra属性"></a>3、Extra属性</h3><p>该属性通常用于多个Activity之间进行数据交换，Intent的Extra属性值应该是一个Bundle对象。</p><h3 id="4、Flag属性"><a href="#4、Flag属性" class="headerlink" title="4、Flag属性"></a>4、Flag属性</h3><p>该属性用于为该Intent添加一些额外的控制旗标。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍-Intent-的一些特殊使用（未完待续）&quot;&gt;&lt;a href=&quot;#介绍-Intent-的一些特殊使用（未完待续）&quot; class=&quot;headerlink&quot; title=&quot;介绍 Intent 的一些特殊使用（未完待续）&quot;&gt;&lt;/a&gt;介绍 Intent 的一些特殊使用（未完待续）&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://chennuo.online/categories/Android/"/>
    
    
  </entry>
  
</feed>
